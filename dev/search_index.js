var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Histories","page":"API reference","title":"Histories","text":"","category":"section"},{"location":"api/#Analysis","page":"API reference","title":"Analysis","text":"","category":"section"},{"location":"api/#Modification","page":"API reference","title":"Modification","text":"","category":"section"},{"location":"api/#Point-processes","page":"API reference","title":"Point processes","text":"","category":"section"},{"location":"api/#Intensity","page":"API reference","title":"Intensity","text":"","category":"section"},{"location":"api/#Marks","page":"API reference","title":"Marks","text":"","category":"section"},{"location":"api/#Simulation","page":"API reference","title":"Simulation","text":"","category":"section"},{"location":"api/#Inference","page":"API reference","title":"Inference","text":"","category":"section"},{"location":"api/#Poisson-processes","page":"API reference","title":"Poisson processes","text":"","category":"section"},{"location":"api/#Univariate","page":"API reference","title":"Univariate","text":"","category":"section"},{"location":"api/#Multivariate","page":"API reference","title":"Multivariate","text":"","category":"section"},{"location":"api/#Hawkes-Process","page":"API reference","title":"Hawkes Process","text":"","category":"section"},{"location":"api/#Goodness-of-fit-tests","page":"API reference","title":"Goodness-of-fit tests","text":"","category":"section"},{"location":"api/#Statistic","page":"API reference","title":"Statistic","text":"","category":"section"},{"location":"api/#BootstrapTest","page":"API reference","title":"BootstrapTest","text":"","category":"section"},{"location":"api/#NoBootstrapTest","page":"API reference","title":"NoBootstrapTest","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"Modules = [PointProcesses]","category":"section"},{"location":"api/#PointProcesses","page":"API reference","title":"PointProcesses","text":"PointProcesses\n\nA package for temporal point process modeling, simulation and inference.\n\n\n\n\n\n","category":"module"},{"location":"api/#PointProcesses.History","page":"API reference","title":"PointProcesses.History","text":"History{T<:Real, M}\n\nLinear event histories with temporal locations of type T and marks of type M.\n\nFields\n\ntimes::Vector{T}: sorted vector of event times\ntmin::T: start time\ntmax::T: end time\nmarks::Vector{M}: associated vector of event marks\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.event_marks","page":"API reference","title":"PointProcesses.event_marks","text":"event_marks(h)\n\nReturn the vector of event marks for h, sorted according to their event times.\n\n\n\n\n\nevent_marks(h, tmin, tmax)\n\nReturn the sorted vector of marks of events between tmin and tmax in h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.event_times","page":"API reference","title":"PointProcesses.event_times","text":"event_times(h)\n\nReturn the sorted vector of event times for h.\n\n\n\n\n\nevent_times(h, tmin, tmax)\n\nReturn the sorted vector of event times between tmin and tmax in h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_time","page":"API reference","title":"PointProcesses.min_time","text":"min_time(h)\n\nReturn the starting time of h (not the same as the first event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_time","page":"API reference","title":"PointProcesses.max_time","text":"max_time(h)\n\nReturn the end time of h (not the same as the last event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.nb_events","page":"API reference","title":"PointProcesses.nb_events","text":"nb_events(h)\n\nCount events in h.\n\n\n\n\n\nnb_events(h, tmin, tmax)\n\nCount events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.has_events","page":"API reference","title":"PointProcesses.has_events","text":"has_events(h)\n\nCheck the presence of events in h.\n\n\n\n\n\nhas_events(h, tmin, tmax)\n\nCheck the presence of events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API reference","title":"Base.length","text":"length(h)\n\nAlias for nb_events(h).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.duration","page":"API reference","title":"PointProcesses.duration","text":"duration(h)\n\nCompute the difference h.tmax - h.tmin.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_mark","page":"API reference","title":"PointProcesses.min_mark","text":"min_mark(h; [init])\n\nReturn the smallest event mark if it is smaller than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_mark","page":"API reference","title":"PointProcesses.max_mark","text":"max_mark(h; [init])\n\nReturn the largest event mark if it is larger than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.push!","page":"API reference","title":"Base.push!","text":"push!(h, t, m)\n\nAdd event (t, m) inside the interval [h.tmin, h.tmax) at the end of history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.append!","page":"API reference","title":"Base.append!","text":"append!(h, ts, ms)\n\nAppend events (ts, ms) inside the interval [h.tmin, h.tmax) at the end of history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.cat","page":"API reference","title":"Base.cat","text":"cat(h1, h2)\n\nIf h1 and h2 are consecutive event histories, i.e., the end of h1 coincides with the beginning of h2, then create a new event history by concatenating h1 and h2.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.time_change","page":"API reference","title":"PointProcesses.time_change","text":"time_change(h, Λ)\n\nApply the time rescaling t -> Λ(t) to history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.split_into_chunks","page":"API reference","title":"PointProcesses.split_into_chunks","text":"split_into_chunks(h, chunk_duration)\n\nSplit h into a vector of consecutive histories with individual duration chunk_duration.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.AbstractPointProcess","page":"API reference","title":"PointProcesses.AbstractPointProcess","text":"AbstractPointProcess\n\nCommon interface for all temporal point processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BoundedPointProcess","page":"API reference","title":"PointProcesses.BoundedPointProcess","text":"BoundedPointProcess{P,T} <: AbstractPointProcess{}\n\nTemporal point process P with pre-defined start and end times.\n\nImplements some fallbacks for the AbstractPointProcess interface which accept fewer arguments.\n\nFields\n\npp::P: underlying point process\ntmin::T: start time\ntmax::T: end time\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.intensity","page":"API reference","title":"PointProcesses.intensity","text":"intensity(pp, m, t, h)\n\nCompute the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\nThe conditional intensity function λ(t,m|h) quantifies the instantaneous risk of an event with mark m occurring at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity","page":"API reference","title":"PointProcesses.ground_intensity","text":"ground_intensity(pp, h, t)\n\nCompute the ground intensity for a temporal point process pp applied to history h at time t.\n\nThe ground intensity quantifies the instantaneous risk of an event with any mark occurring at time t after history h:\n\nλg(t|h) = Σₘ λ(t,m|h)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.log_intensity","page":"API reference","title":"PointProcesses.log_intensity","text":"log_intensity(pp, m, t, h)\n\nCompute the logarithm of the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.intensity_vector","page":"API reference","title":"PointProcesses.intensity_vector","text":"intensity_vector(pp<:MultivariatePoissonProcess)\n\nCompute the vector of the marginal intensities λ for a multivariate Poisson process.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.mark_distribution","page":"API reference","title":"PointProcesses.mark_distribution","text":"mark_distribution(pp, t, h)\n\nCompute the distribution of marks for a temporal point process pp knowing that an event takes place at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.simulate_ogata","page":"API reference","title":"PointProcesses.simulate_ogata","text":"simulate_ogata(rng, pp, tmin, tmax)\n\nSimulate a temporal point process pp on interval [tmin, tmax) using Ogata's algorithm.\n\nTechnical Remark\n\nTo infer the type of the marks, the implementation assumes that there is method of mark_distribution without the argument h such that it corresponds to the distribution of marks in case the history is empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.simulate","page":"API reference","title":"PointProcesses.simulate","text":"simulate([rng,] pp, tmin, tmax)\n\nAlias for simulate_ogata.\n\n\n\n\n\nsimulate([rng,] bpp::BoundedPointProcess)\n\nSimulate a point process on a predefined time interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityInterface.logdensityof","page":"API reference","title":"DensityInterface.logdensityof","text":"logdensityof(pp, h)\n\nCompute the log probability density function for a temporal point process pp applied to history h:\n\nℓ(h) = Σₖ log λ(tₖ|hₖ) - Λ(h)\n\nThe default method uses a loop over events combined with integrated_ground_intensity, but it should be reimplemented for specific processes if faster computation is possible.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.integrated_ground_intensity","page":"API reference","title":"PointProcesses.integrated_ground_intensity","text":"integrated_ground_intensity(pp, h, a, b)\n\nCompute the integrated ground intensity (or compensator) Λ(t|h) for a temporal point process pp applied to history h on interval [a, b):\n\nΛ(h) = ∫ λg(t|h) dt\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity_bound","page":"API reference","title":"PointProcesses.ground_intensity_bound","text":"ground_intensity_bound(pp, t, h)\n\nCompute a local upper bound on the ground intensity for a temporal point process pp applied to history h at time t.\n\nReturn a tuple of the form (B, L) satisfying λg(t|h) ≤ B for all u ∈ [t, t+L).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.fit","page":"API reference","title":"StatsAPI.fit","text":"fit(::Type{PP}, h)\nfit(::Type{PP}, histories)\n\nFit a point process of type PP to one or several histories.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.fit_map","page":"API reference","title":"PointProcesses.fit_map","text":"fit_map(::Type{PP}, h, prior)\nfit_map(::Type{PP}, histories, prior)\n\nFit a point process of type PP to one or several histories using maximum a posteriori with a prior.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.PoissonProcess","page":"API reference","title":"PointProcesses.PoissonProcess","text":"PoissonProcess{R,D}\n\nHomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nλ::R: ground intensity.\nmark_dist::D: mark distribution.\n\nConstructor\n\nPoissonProcess(λ, mark_dist)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.UnivariatePoissonProcess","page":"API reference","title":"PointProcesses.UnivariatePoissonProcess","text":"UnivariatePoissonProcess{R}\n\nHomogeneous univariate temporal Poisson process with scalar intensity λ::R.\n\nUnivariatePoissonProcess{R} is simply a type alias for PoissonProcess{R,Dirac{Nothing}}.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcess","page":"API reference","title":"PointProcesses.MultivariatePoissonProcess","text":"MultivariatePoissonProcess{R}\n\nHomogeneous multivariate temporal Poisson process with marginal intensities of type R.\n\nMultivariatePoissonProcess{R} is simply a type alias for PoissonProcess{R,Categorical{Float64,Vector{Float64}}}.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcessPrior","page":"API reference","title":"PointProcesses.MultivariatePoissonProcessPrior","text":"MultivariatePoissonProcessPrior{R1,R2}\n\nGamma prior on all the event rates of a MultivariatePoissonProcess.\n\nFields\n\nα::Vector{R1}\nβ::R2\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.HawkesProcess","page":"API reference","title":"PointProcesses.HawkesProcess","text":"HawkesProcess{T<:Real}\n\nUnivariate Hawkes process with exponential decay kernel.\n\nA Hawkes process is a self-exciting point process where each event increases the probability of future events. The conditional intensity function is given by:\n\nλ(t) = μ + α ∑_{tᵢ < t} exp(-ω(t - tᵢ))\n\nwhere the sum is over all previous event times tᵢ.\n\nFields\n\nμ::T: baseline intensity (immigration rate)\nα::T: jump size (immediate increase in intensity after an event)  \nω::T: decay rate (how quickly the excitement fades)\n\nConditions:\n\nμ, α, ω >= 0\nψ = α/ω < 1 → Stability condition. ψ is the expected number of events each event generates\n\nFollowing the notation from E. Lewis, G. Mohler (2011).\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.Statistic","page":"API reference","title":"PointProcesses.Statistic","text":"Statistic\n\nInterface for all test statistics.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.statistic","page":"API reference","title":"PointProcesses.statistic","text":"statistic(::Statistic, pp::AbstractPointProcess, h::History)\n\nCompute the value of the test statistic with respect to pp and h.\n\nArguments\n\n::Statistic: The type of test statistic to be computed\npp::AbstractPointProcess: null-hypothesis model for the event history h\nh::History: the observed event history\n\nReturns\n\nFloat64: the resulting test statistic\n\nExample\n\n#=\nCalculate the Kolmogorov-Smirnov distance between the distribution of the\ntime-changed event times of `h` and a standard exponential.\n=#\nks_stat = statistic(KSDistance{Exponential}, hawkes_process, history)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.PointProcessTest","page":"API reference","title":"PointProcesses.PointProcessTest","text":"PointProcessTest\n\nInterface for all goodness-of-fit tests\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.pvalue","page":"API reference","title":"StatsAPI.pvalue","text":"pvalue(test::PointProcessTest)\n\nCalculate the p-value of a goodness-of-fit test on a process.\n\nArguments\n\n::PointProcessTest: the test result object\n\nReturns\n\nFloat64: p-value in [0, 1], where small values provide evidence against the null hypothesis\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.KSDistance","page":"API reference","title":"PointProcesses.KSDistance","text":"KSDistance{T<:UnivariateDistribution}\n\nA Kolmogorov-Smirnov distance statistic for testing goodness-of-fit of point processes against a specified distribution D after appropriate time rescaling. This test statistic is suitable only for non-marked processes, as it ignores the marks.\n\nType parameter\n\nD<:UnivariateDistribution: the target distribution to test against (e.g., Exponential, Uniform)\n\nAvailable test statistics\n\nKSDistance{Exponential}   Kolmogorov-Smirnov distance between the time-changed interevent times and a standard exponential\nKSDistance{Uniform}   Kolmogorov-Smirnov distance between the time-changed event times and a uniform distribution\n\nExample\n\nBootstrapTest(KSDistance{Exponential}, HawkesProcess, history)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BootstrapTest","page":"API reference","title":"PointProcesses.BootstrapTest","text":"BootstrapTest <: PointProcessTest\n\nAn object containing the results of a bootstrap-based goodness-of-fit test. The p-value of the test is calculated as     p = (count(simstats ≥ stat) + 1) / (nsims + 1).\n\nFields\n\nn_sims::Int: number of bootstrap simulations performed\nstat::Float64: observed test statistic value\nsim_stats::Vector{Float64}: test statistics from bootstrap simulations\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BootstrapTest-Tuple{Type{<:Statistic}, Type{<:AbstractPointProcess}, History}","page":"API reference","title":"PointProcesses.BootstrapTest","text":"BootstrapTest(S::Type{<:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())\n\nPerform a goodness-of-fit test using simulation with bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.\n\nIf λ₀(t) is the true intensity function of the process that generated the observed history, and λ(t; θ) is a a parametrization of the intensity, then the null hypothesis is\n\nH₀: There exists parameters θₒ such that λ₀(t) = λ(t; θ₀)\n\nThis procedure is specifically aimed for testing hypotheses where parameters need to be estimated. Details are provided in Kling and Vetter (2025).\n\nArguments\n\nS::Type{<:Statistic}: the type of test statistic to use\npp::Type{<:AbstractPointProcess}: the null hypothesis model family\nh::History: the observed event history\nn_sims::Int=1000: number of bootstrap simulations to perform\nrng::AbstractRNG=default_rng(): Random number generator\n\nReturns\n\nBootstrapTest: test result object containing the observed statistic, bootstrap statistics, and test metadata\n\nExample\n\n# Bootstrap test for Hawkes process model adequacy\ntest = BootstrapTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)\np = pvalue(test)\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.MonteCarloTest","page":"API reference","title":"PointProcesses.MonteCarloTest","text":"MonteCarloTest <: PointProcessTest\n\nAn object containing the results of a non-bootstrap based goodness-of-fit test. The p-value of the test is calculated as     p = (count(simstats ≥ stat) + 1) / (nsims + 1).\n\nFields\n\nn_sims::Int: number of simulations performed\nstat::Float64: observed test statistic value\nsim_stats::Vector{Float64}: test statistics from simulated data\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MonteCarloTest-Tuple{Type{<:Statistic}, AbstractPointProcess, History}","page":"API reference","title":"PointProcesses.MonteCarloTest","text":"MonteCarloTest(S::Type{<:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())\n\nPerform a goodness-of-fit test using simulation without bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.\n\nIf λ₀(t) is the true intensity function of the process that generated the observed history, and λ(t; θ) is a a parametrization of the intensity, then there are two forms for the null hypothesis:\n\n1. H₀: λ₀(t) = λ(t; θ₀)\n2. H₀: There exists parameters θₒ such that λ₀(t) = λ(t; θ₀)\n\nIf pp is an instance of an AbstractPointProcess, the null hypothesis 1 is considered, if a pp is a Type{<:AbstractPointProcess}, the method uses null hypothesis 2.\n\nNotice that this test is better suited when the parameter θ₀ is known (form 1), since this procedure does not account for parameter estimation error. For more details on this, see Jogesh Babu and Rao (2004), Reynaud-Bouret et. al. (2014),  Kling and Vetter (2025).\n\nArguments\n\nS::Type{<:Statistic}: the type of test statistic to use\npp::Union{AbstractPointProcess, Type{<:AbstractPointProcess}}: the null hypothesis model family\nh::History: the observed event history\nn_sims::Int=1000: number of simulations to perform for the test\nrng::AbstractRNG=default_rng(): Random number generator\n\nReturns\n\nMonteCarloTest: test result object containing the observed statistic, simulated statistics, and test metadata\n\nExample\n\n# Test null hypothesis of form 1. Known θ₀\ntest = MonteCarloTest(KSDistance(Exponential), HawkesProcess(1, 1, 2), history; n_sims=1000)\np = pvalue(test)\n# Test null hypothesis of form 2. Unknown θ₀\ntest = MonteCarloTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)\np = pvalue(test)\n\n\n\n\n\n","category":"method"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"Here is a list of features that are yet to be implemented...","category":"section"},{"location":"roadmap/#Soon","page":"Roadmap","title":"Soon","text":"Compatibility with reverse-mode AD (Zygote.jl)\nHawkes processes\nCox processes\nMarkov-Modulated Poisson Processes\nPrediction and evaluation utilities","category":"section"},{"location":"roadmap/#Someday","page":"Roadmap","title":"Someday","text":"Poisson processes on arbitrary measured spaces\nPiecewise-Deterministic Markov Processes\nGaussian Process-modulated Poisson Processes","category":"section"},{"location":"roadmap/#Maybe-not","page":"Roadmap","title":"Maybe not","text":"Neural point processes?\nInterface with MLJ.jl?\nInterface with Turing.jl?","category":"section"},{"location":"#PointProcesses.jl","page":"Home","title":"PointProcesses.jl","text":"Welcome to the documentation of PointProcesses.jl, a package for modeling, simulation and inference with temporal point processes.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install the latest release available in the General registry, run the following code in Julia's REPL:\n\nimport Pkg; Pkg.add(\"PointProcesses\")\n\nTo install the current development version, run this code instead:\n\nimport Pkg; Pkg.add(url=\"https://github.com/JoseKling/PointProcesses.jl\")","category":"section"},{"location":"#Mathematical-background","page":"Home","title":"Mathematical background","text":"Temporal point processes are a way to describe collections of events with time stamps. Please refer to the tutorial (Rasmussen, Jun 2018) for details.\n\nRasmussen, J. G. (Jun 2018). Lecture Notes: Temporal Point Processes and the Conditional Intensity Function. Accessed on Jul 17, 2023, arXiv:1806.00221 [stat].\n\n\n\n","category":"section"}]
}
