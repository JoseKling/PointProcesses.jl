var documenterSearchIndex = {"docs":
[{"location":"examples/Hawkes/#Fitting-data-to-a-Hawkes-Process-Model","page":"Hawkes","title":"Fitting data to a Hawkes Process Model","text":"This tutorial demonstrates how to fit data to a Hawkes point process model using maximum likelihood estimation (MLE). We will go over the basics of Hawkes processes, why they are useful, and how to implement them in PointProcesses.jl. We will first begin with a recap of the math of a general Hawkes process.","category":"section"},{"location":"examples/Hawkes/#A-Quick-Recap-of-Hawkes-Processes","page":"Hawkes","title":"A Quick Recap of Hawkes Processes","text":"A Hawkes process is a type of temporal point process that models self-exciting behavior, where the occurrence of an event increases the likelihood of future events occurring in the near future. The intensity function of a general Hawkes process is given by: Œª(tmathcal H_t) = Œº(t) + _t·µ¢  t phi(t - t·µ¢) where Œº(t) is the baseline intensity, which accounts for spontaneous events, mathcal H_t is the history of events up until time t, and phi(cdot) is the triggering kernel, which controls how past events influence future events.\n\nOne of the most common choices for this kernel is the exponential function: phi(s) = alphaexp-beta s. In this model, Œ± is the strength of self-exciting, and Œ≤ controls the rate of excitation decay. Given these parameters, the intensity function is: Œª(tmathcal H_t) = Œº + sum_t_i  t alpha exp-beta (t - t_i). We assume that Œº is constant for simplicity. But, we could generalize this to be inhomogeneous.\n\nAn important statistic of the Hawkes process is the branching ratio which is a measure of the expected number of \"daughter\" events, a \"parent\" event will create. For the exponential kernel, this is given by the following equation: n = fracalphabeta. In the event that n < 1, the process is subcritical, meaning that events will eventually die out. If n = 1, the process is critical, and if n > 1, the process is supercritical, meaning that events can lead to an infinite cascade of events.\n\nLet's now apply this theory, and develop more through the process, by fitting a Hawkes process to some data.\n\nusing Clustering\nusing CSV\nusing DataFrames\nusing Dates\nusing Distributions\nusing PointProcesses\nusing Plots\n\nFirst let's open our data. This data records litter box entries taken from three cats over a period of one month.\n\nroot = pkgdir(PointProcesses)\ndata = CSV.read(joinpath(root, \"docs\", \"examples\", \"data\", \"cats.csv\"), DataFrame);\nnothing #hide\n\nThis dataset has three cats in it, so let's first separate out each cat, using their weight to infer their identity\n\ncat_weights = [parse(Float64, split(i)[1]) for i in data.Value]\nclusters = kmeans(reshape(cat_weights, 1, :), 3; maxiter=100, display=:none)\n\ndata.CatWeight = cat_weights\ndata.CatID = clusters.assignments;\nnothing #hide\n\nNow that we have set this up we need to get the timestamps in a useable order for plotting. We can use the Dates package for this.\n\nfmt = dateformat\"m/d I:M p\"\ndt = DateTime(\"12/22 3:09 pm\", fmt)\n\nfunction parse_timestamp_min(s::AbstractString; year=2024)\n    dt = DateTime(s, dateformat\"m/d I:M p\")\n    DateTime(year, month(dt), day(dt), hour(dt), minute(dt))\nend\n\ndata.TimestampDT = parse_timestamp_min.(String.(data.Timestamp))\n\nt0 = minimum(data.TimestampDT)\ndata.t = (data.TimestampDT .- t0) ./ Minute(1)  # Float64 minutes since first event\n\nSince this dataset only has resolution up to the nearest minute, we need to check if there are any \"ties\" as the Hawkes process model requires unique event times.\n\nif any(diff(sort(data.t)) .== 0)\n    println(\n        \"Data contains tied event times. Please add small jitter to event times to make them unique.\",\n    )\nelse\n    println(\"Data contains no tied event times. Proceed with fitting. Yay!\")\nend\n\nGreat! We can now move forward. First, let's visualize the data using a simple event plot.\n\nfunction eventplot(\n    event_times::Vector{Float64};\n    title=\"Event Plot\",\n    xlabel=\"Time (minutes)\",\n    ylabel=\"Events\",\n)\n    scatter(\n        event_times,\n        ones(length(event_times));\n        markershape=:vline,\n        markersize=10,\n        label=\"\",\n        title=title,\n        xlabel=xlabel,\n        ylabel=ylabel,\n        yticks=false,\n    )\nend\n\ncat1_times = data.t[data.CatID .== 1]\ncat2_times = data.t[data.CatID .== 2]\ncat3_times = data.t[data.CatID .== 3]\n\np1 = eventplot(cat1_times; title=\"Cat 1 Litter Box Entries\")\np2 = eventplot(cat2_times; title=\"Cat 2 Litter Box Entries\")\np3 = eventplot(cat3_times; title=\"Cat 3 Litter Box Entries\")\n\nplot(p1, p2, p3; layout=(3, 1), size=(800, 600))\n\nFrom the plot above, we can see that events qualitatively arrive together. This could mean that if one cat uses the litter box, then another is soon to follow. To further understand the data, let's plot the intensity function for the average day. We can use the Inhomogeneous Poisson Process models in PointProcesses.jl to fit a piecewise constant intensity function to the data. This will give us an idea of the average litter box usage over the course of a day. While this will not give us any information about self-exciting behavior, it will help us understand the daily patterns of litter box usage.\n\ntod = minute.(data.TimestampDT) .+ 60 .* hour.(data.TimestampDT) # time-of-day in minutes since midnight\nday = Date.(data.TimestampDT)\nn_days = length(unique(day))\nh_day = History(sort(Float64.(tod)), 0.0, 1440.0) # build a \"history\" on [0, 1440] minutes\nnbins = 96  # 96 bins = 15-minute bins\npp_day = fit(\n    InhomogeneousPoissonProcess{PiecewiseConstantIntensity{Float64},Dirac{Nothing}},\n    h_day,\n    nbins,\n)\n\nŒª_avg(u) = pp_day.intensity_function(u) / n_days\n\nu = range(0.0, 1440.0; length=2000)\nplot(\n    u ./ 60,\n    Œª_avg.(u);\n    xlabel=\"Time of day (hours)\",\n    ylabel=\"Empirical intensity (events/min)\",\n    title=\"Average-day empirical intensity (piecewise constant)\",\n    legend=false,\n)\n\nFrom the plot we can see the intensity function has two peaks, one at around 7-10 AM and the other at 8-10 PM. Now, let's fit a Hawkes process to the data. We will for now, ignore the cat identities and fit a single Hawkes process to all the data. The goal of this analysis is to understand the self-exciting nature of the litter box entries. I.e., if one cat uses the litter box, does that increase the likelihood of another cat using it soon after? To do this, we can use the implementation in PointProcesses.jl\n\nfull_history = History(data.t, 0.0, maximum(data.t) + 1.0)\nhawkes_model = fit(HawkesProcess, full_history)\n\nprintln(\"Fitted Hawkes Process Parameters:\") # hide\nprintln(\"Base intensity (Œº): \", hawkes_model.Œº) # hide\nprintln(\"Excitation parameter (Œ±): \", hawkes_model.Œ±) # hide\nprintln(\"Decay rate (œâ): \", hawkes_model.œâ) # hide\nprintln(\"Branching ratio (n = Œ±/œâ): \", hawkes_model.Œ± / hawkes_model.œâ) #hide\n\nWe can now evaluate the branching ratio and parameters of the fitted model. The branching ratio tells us the expected number of \"daughter\" events that a \"parent\" event will create. If this value is significantly greater than 0, it suggests that the litter box entries are self-exciting, meaning that one entry increases the likelihood of subsequent entries in the near future. If the branching ratio is close to 0, it suggests that the entries are more random and not influenced by previous entries. In this case, we can see that the branching ratio is around 0.42, suggesting a moderate level of self-excitation in the litter box entries. Finally, we can visualize the fitted intensity function over time.\n\nts = sort(data.t)\n\nfunction Œª_hawkes(t::Real)\n    hawkes_model.Œº +\n    sum((hawkes_model.Œ± * exp(-hawkes_model.œâ * (t - ti)) for ti in ts if ti < t); init=0.0)\nend\n\nu = range(0.0, maximum(ts) + 1.0; length=2000)\n\nplot(\n    u,\n    Œª_hawkes.(u);\n    xlabel=\"Time (minutes)\",\n    ylabel=\"Fitted Hawkes intensity (events/min)\",\n    title=\"Fitted Hawkes Process Intensity Function\",\n    legend=false,\n)\n\nFrom the plot, we can observe how the intensity function varies over time, capturing the self-exciting nature of the litter box entries. Like any good statistical analysis, it is important to assess goodness of fit. We will rely on the most useful method in point processes: the time-rescaling theorem. Luckily, PointProcesses.jl has inbuilt functionality to assess goodness of fit using this theorem. We will use a Monte Carlo test to compare the empirical KS distance of the rescaled times against simulated data from the fitted Hawkes process.\n\ntest = MonteCarloTest(KSDistance{Exponential}, hawkes_model, full_history; n_sims=1000)\n\np = pvalue(test) # hide\nprintln(\"Monte Carlo Test p-value for Hawkes Process fit: \", p) # hide\nprintln(\n    \"Assuming a significance level of 0.05, we \" *\n    (p < 0.05 ? \"reject\" : \"fail to reject\") *\n    \"\",\n) # hide\nprintln(\"the null hypothesis that the Hawkes process is a good fit to the data.\") # hide\n\nFrom this analysis, it seems that we can say that litter-box usage is indeed a self-exciting process, as the fitted Hawkes process provides a good fit to the data. It's worth considering that we have ignored the identities of the cats in this analysis. A more thorough analysis could involve fitting a multivariate Hawkes process, where each cat is represented as a separate dimension. This would allow us to capture the interactions between the cats more accurately. This will be the subject of a future tutorial.","category":"section"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Histories","page":"API reference","title":"Histories","text":"","category":"section"},{"location":"api/#Analysis","page":"API reference","title":"Analysis","text":"","category":"section"},{"location":"api/#Modification","page":"API reference","title":"Modification","text":"","category":"section"},{"location":"api/#Point-processes","page":"API reference","title":"Point processes","text":"","category":"section"},{"location":"api/#Intensity","page":"API reference","title":"Intensity","text":"","category":"section"},{"location":"api/#Marks","page":"API reference","title":"Marks","text":"","category":"section"},{"location":"api/#Simulation","page":"API reference","title":"Simulation","text":"","category":"section"},{"location":"api/#Inference","page":"API reference","title":"Inference","text":"","category":"section"},{"location":"api/#Poisson-processes","page":"API reference","title":"Poisson processes","text":"","category":"section"},{"location":"api/#Univariate","page":"API reference","title":"Univariate","text":"","category":"section"},{"location":"api/#Multivariate","page":"API reference","title":"Multivariate","text":"","category":"section"},{"location":"api/#Inhomogeneous-Poisson-Process","page":"API reference","title":"Inhomogeneous Poisson Process","text":"","category":"section"},{"location":"api/#Intensity-Functions","page":"API reference","title":"Intensity Functions","text":"","category":"section"},{"location":"api/#Configuration","page":"API reference","title":"Configuration","text":"","category":"section"},{"location":"api/#Hawkes-Process","page":"API reference","title":"Hawkes Process","text":"","category":"section"},{"location":"api/#Goodness-of-fit-tests","page":"API reference","title":"Goodness-of-fit tests","text":"","category":"section"},{"location":"api/#Statistic","page":"API reference","title":"Statistic","text":"","category":"section"},{"location":"api/#BootstrapTest","page":"API reference","title":"BootstrapTest","text":"","category":"section"},{"location":"api/#NoBootstrapTest","page":"API reference","title":"NoBootstrapTest","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"Modules = [PointProcesses]","category":"section"},{"location":"api/#PointProcesses","page":"API reference","title":"PointProcesses","text":"PointProcesses\n\nA package for temporal point process modeling, simulation and inference.\n\n\n\n\n\n","category":"module"},{"location":"api/#PointProcesses.History","page":"API reference","title":"PointProcesses.History","text":"History{T<:Real, M}\n\nLinear event histories with temporal locations of type T and marks of type M.\n\nFields\n\ntimes::Vector{T}: sorted vector of event times\ntmin::T: start time\ntmax::T: end time\nmarks::Vector{M}: associated vector of event marks\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.event_marks","page":"API reference","title":"PointProcesses.event_marks","text":"event_marks(h)\n\nReturn the vector of event marks for h, sorted according to their event times.\n\n\n\n\n\nevent_marks(h, tmin, tmax)\n\nReturn the sorted vector of marks of events between tmin and tmax in h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.event_times","page":"API reference","title":"PointProcesses.event_times","text":"event_times(h)\n\nReturn the sorted vector of event times for h.\n\n\n\n\n\nevent_times(h, tmin, tmax)\n\nReturn the sorted vector of event times between tmin and tmax in h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_time","page":"API reference","title":"PointProcesses.min_time","text":"min_time(h)\n\nReturn the starting time of h (not the same as the first event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_time","page":"API reference","title":"PointProcesses.max_time","text":"max_time(h)\n\nReturn the end time of h (not the same as the last event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.nb_events","page":"API reference","title":"PointProcesses.nb_events","text":"nb_events(h)\n\nCount events in h.\n\n\n\n\n\nnb_events(h, tmin, tmax)\n\nCount events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.has_events","page":"API reference","title":"PointProcesses.has_events","text":"has_events(h)\n\nCheck the presence of events in h.\n\n\n\n\n\nhas_events(h, tmin, tmax)\n\nCheck the presence of events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API reference","title":"Base.length","text":"length(h)\n\nAlias for nb_events(h).\n\n\n\n\n\nlength(pp::MultivariatePoissonProcess)\n\nReturn the number of marks (dimensions) in a multivariate Poisson process.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.duration","page":"API reference","title":"PointProcesses.duration","text":"duration(h)\n\nCompute the difference h.tmax - h.tmin.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_mark","page":"API reference","title":"PointProcesses.min_mark","text":"min_mark(h; [init])\n\nReturn the smallest event mark if it is smaller than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_mark","page":"API reference","title":"PointProcesses.max_mark","text":"max_mark(h; [init])\n\nReturn the largest event mark if it is larger than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.push!","page":"API reference","title":"Base.push!","text":"push!(h, t, m)\n\nAdd event (t, m) inside the interval [h.tmin, h.tmax) at the end of history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.append!","page":"API reference","title":"Base.append!","text":"append!(h, ts, ms)\n\nAppend events (ts, ms) inside the interval [h.tmin, h.tmax) at the end of history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.cat","page":"API reference","title":"Base.cat","text":"cat(h1, h2)\n\nIf h1 and h2 are consecutive event histories, i.e., the end of h1 coincides with the beginning of h2, then create a new event history by concatenating h1 and h2.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.time_change","page":"API reference","title":"PointProcesses.time_change","text":"time_change(h, Œõ)\n\nApply the time rescaling t -> Œõ(t) to history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.split_into_chunks","page":"API reference","title":"PointProcesses.split_into_chunks","text":"split_into_chunks(h, chunk_duration)\n\nSplit h into a vector of consecutive histories with individual duration chunk_duration.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.AbstractPointProcess","page":"API reference","title":"PointProcesses.AbstractPointProcess","text":"AbstractPointProcess\n\nCommon interface for all temporal point processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BoundedPointProcess","page":"API reference","title":"PointProcesses.BoundedPointProcess","text":"BoundedPointProcess{P,T} <: AbstractPointProcess{}\n\nTemporal point process P with pre-defined start and end times.\n\nImplements some fallbacks for the AbstractPointProcess interface which accept fewer arguments.\n\nFields\n\npp::P: underlying point process\ntmin::T: start time\ntmax::T: end time\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.intensity","page":"API reference","title":"PointProcesses.intensity","text":"intensity(pp, m, t, h)\n\nCompute the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\nThe conditional intensity function Œª(t,m|h) quantifies the instantaneous risk of an event with mark m occurring at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity","page":"API reference","title":"PointProcesses.ground_intensity","text":"ground_intensity(pp, h, t)\n\nCompute the ground intensity for a temporal point process pp applied to history h at time t.\n\nThe ground intensity quantifies the instantaneous risk of an event with any mark occurring at time t after history h:\n\nŒªg(t|h) = Œ£‚Çò Œª(t,m|h)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.log_intensity","page":"API reference","title":"PointProcesses.log_intensity","text":"log_intensity(pp, m, t, h)\n\nCompute the logarithm of the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.intensity_vector","page":"API reference","title":"PointProcesses.intensity_vector","text":"intensity_vector(pp<:MultivariatePoissonProcess)\n\nCompute the vector of the marginal intensities Œª for a multivariate Poisson process.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.mark_distribution","page":"API reference","title":"PointProcesses.mark_distribution","text":"mark_distribution(pp, t, h)\n\nCompute the distribution of marks for a temporal point process pp knowing that an event takes place at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.simulate_ogata","page":"API reference","title":"PointProcesses.simulate_ogata","text":"simulate_ogata(rng, pp, tmin, tmax)\n\nSimulate a temporal point process pp on interval [tmin, tmax) using Ogata's algorithm.\n\nTechnical Remark\n\nTo infer the type of the marks, the implementation assumes that there is method of mark_distribution without the argument h such that it corresponds to the distribution of marks in case the history is empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.simulate","page":"API reference","title":"PointProcesses.simulate","text":"simulate([rng,] pp, tmin, tmax)\n\nAlias for simulate_ogata.\n\n\n\n\n\nsimulate([rng,] bpp::BoundedPointProcess)\n\nSimulate a point process on a predefined time interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityInterface.logdensityof","page":"API reference","title":"DensityInterface.logdensityof","text":"logdensityof(pp, h)\n\nCompute the log probability density function for a temporal point process pp applied to history h:\n\n‚Ñì(h) = Œ£‚Çñ log Œª(t‚Çñ|h‚Çñ) - Œõ(h)\n\nThe default method uses a loop over events combined with integrated_ground_intensity, but it should be reimplemented for specific processes if faster computation is possible.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.integrated_ground_intensity","page":"API reference","title":"PointProcesses.integrated_ground_intensity","text":"integrated_ground_intensity(pp, h, a, b)\n\nCompute the integrated ground intensity (or compensator) Œõ(t|h) for a temporal point process pp applied to history h on interval [a, b):\n\nŒõ(h) = ‚à´ Œªg(t|h) dt\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity_bound","page":"API reference","title":"PointProcesses.ground_intensity_bound","text":"ground_intensity_bound(pp, t, h)\n\nCompute a local upper bound on the ground intensity for a temporal point process pp applied to history h at time t.\n\nReturn a tuple of the form (B, L) satisfying Œªg(t|h) ‚â§ B for all u ‚àà [t, t+L).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.fit","page":"API reference","title":"StatsAPI.fit","text":"fit(::Type{PP}, h)\nfit(::Type{PP}, histories)\n\nFit a point process of type PP to one or several histories.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.fit_map","page":"API reference","title":"PointProcesses.fit_map","text":"fit_map(::Type{PP}, h, prior)\nfit_map(::Type{PP}, histories, prior)\n\nFit a point process of type PP to one or several histories using maximum a posteriori with a prior.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.PoissonProcess","page":"API reference","title":"PointProcesses.PoissonProcess","text":"PoissonProcess{R,D}\n\nHomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nŒª::R: ground intensity.\nmark_dist::D: mark distribution.\n\nConstructor\n\nPoissonProcess(Œª, mark_dist)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.UnivariatePoissonProcess","page":"API reference","title":"PointProcesses.UnivariatePoissonProcess","text":"UnivariatePoissonProcess{R}\n\nHomogeneous univariate temporal Poisson process with scalar intensity Œª::R.\n\nUnivariatePoissonProcess{R} is simply a type alias for PoissonProcess{R,Dirac{Nothing}}.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcess","page":"API reference","title":"PointProcesses.MultivariatePoissonProcess","text":"MultivariatePoissonProcess{R}\n\nHomogeneous multivariate temporal Poisson process with marginal intensities of type R.\n\nMultivariatePoissonProcess{R} is simply a type alias for PoissonProcess{R,Categorical{Float64,Vector{Float64}}}.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcessPrior","page":"API reference","title":"PointProcesses.MultivariatePoissonProcessPrior","text":"MultivariatePoissonProcessPrior{R1,R2}\n\nGamma prior on all the event rates of a MultivariatePoissonProcess.\n\nFields\n\nŒ±::Vector{R1}\nŒ≤::R2\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.InhomogeneousPoissonProcess","page":"API reference","title":"PointProcesses.InhomogeneousPoissonProcess","text":"InhomogeneousPoissonProcess{F,M,C}\n\nInhomogeneous temporal Poisson process with time-varying intensity.\n\nFields\n\nintensity_function::F: callable intensity function Œª(t).\nmark_dist::M: mark distribution.\nintegration_config::C: configuration for numerical integration.\n\nConstructor\n\nInhomogeneousPoissonProcess(intensity_function, mark_dist; integration_config=IntegrationConfig())\n\nExamples\n\n# Linear intensity\npp = InhomogeneousPoissonProcess(PolynomialIntensity([1.0, 0.5]), Normal())\n\n# Sinusoidal intensity\npp = InhomogeneousPoissonProcess(SinusoidalIntensity(5.0, 2.0, 2œÄ), Categorical([0.3, 0.7]))\n\n# Custom intensity function\npp = InhomogeneousPoissonProcess(t -> 1.0 + 0.5*sin(t), Uniform())\n\n# Custom integration settings\npp = InhomogeneousPoissonProcess(\n    my_intensity,\n    Normal(),\n    integration_config=IntegrationConfig(abstol=1e-10)\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.ParametricIntensity","page":"API reference","title":"PointProcesses.ParametricIntensity","text":"ParametricIntensity\n\nAbstract trait for intensity functions that can be parameterized for MLE fitting.\n\nAny intensity type that implements this interface must provide:\n\nfrom_params(::Type{F}, params): Construct intensity function from parameters\n\nThe parameter space should be unconstrained (e.g., use log-transforms for positive parameters).\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.PolynomialIntensity","page":"API reference","title":"PointProcesses.PolynomialIntensity","text":"PolynomialIntensity{R<:Real,L} <: ParametricIntensity\n\nPolynomial intensity function with optional link function.\n\nFields\n\ncoefficients::Vector{R}: polynomial coefficients [a‚ÇÄ, a‚ÇÅ, ..., a‚Çô].\nlink::L: link function applied to the polynomial (:identity or :log).\n\nConstructor\n\nPolynomialIntensity(coefficients; link=:identity)\n\nWhen link=:identity: Œª(t) = a‚ÇÄ + a‚ÇÅt + a‚ÇÇt¬≤ + ... + a‚Çôt‚Åø When link=:log: Œª(t) = exp(a‚ÇÄ + a‚ÇÅt + a‚ÇÇt¬≤ + ... + a‚Çôt‚Åø)\n\nThe log link ensures positivity of the intensity function.\n\nExamples\n\n# Linear identity: Œª(t) = 2 + 3*t (may be negative!)\nPolynomialIntensity([2.0, 3.0])\n\n# Linear log: Œª(t) = exp(2 + 3*t) (always positive)\nPolynomialIntensity([2.0, 3.0]; link=:log)\n\n# Quadratic: Œª(t) = 1 + 2*t + 0.5*t¬≤\nPolynomialIntensity([1.0, 2.0, 0.5])\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.ExponentialIntensity","page":"API reference","title":"PointProcesses.ExponentialIntensity","text":"ExponentialIntensity{R<:Real} <: ParametricIntensity\n\nExponential intensity function: Œª(t) = aexp(bt).\n\nFields\n\na::R: scaling factor (must be positive).\nb::R: exponential rate.\n\nConstructor\n\nExponentialIntensity(a, b)\n\nExamples\n\n# Increasing intensity\nExponentialIntensity(2.0, 0.1)\n\n# Decreasing intensity\nExponentialIntensity(5.0, -0.05)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.SinusoidalIntensity","page":"API reference","title":"PointProcesses.SinusoidalIntensity","text":"SinusoidalIntensity{R<:Real} <: ParametricIntensity\n\nSinusoidal intensity function: Œª(t) = a + bsin(œât + œÜ).\n\nTo ensure positivity, we require a >= |b| so that Œª(t) >= 0 for all t.\n\nFields\n\na::R: baseline intensity (must satisfy a >= |b|).\nb::R: amplitude.\nœâ::R: angular frequency.\nœÜ::R: phase shift.\n\nConstructor\n\nSinusoidalIntensity(a, b, œâ, œÜ=0.0)\n\nExamples\n\n# Valid: a=5, b=2, so a >= |b|\nSinusoidalIntensity(5.0, 2.0, 2œÄ)\n\n# Valid: a=5, b=-3, so a >= |-3| = 3\nSinusoidalIntensity(5.0, -3.0, 2œÄ)\n\n# Invalid: a=2, b=3, so a < |b| (will error)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.PiecewiseConstantIntensity","page":"API reference","title":"PointProcesses.PiecewiseConstantIntensity","text":"PiecewiseConstantIntensity{R<:Real}\n\nPiecewise constant intensity function.\n\nFields\n\nbreakpoints::Vector{R}: sorted vector of breakpoints (including tmin and tmax).\nrates::Vector{R}: intensity values for each interval.\n\nConstructor\n\nPiecewiseConstantIntensity(breakpoints, rates)\n\nThe intensity is rates[i] for t ‚àà [breakpoints[i], breakpoints[i+1]).\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.LinearCovariateIntensity","page":"API reference","title":"PointProcesses.LinearCovariateIntensity","text":"LinearCovariateIntensity{R<:Real,F}\n\nLinear combination of covariate functions: Œª(t) = Œ≤‚ÇÄ + Œ≤‚ÇÅx‚ÇÅ(t) + Œ≤‚ÇÇx‚ÇÇ(t) + ... + Œ≤‚Çô*x‚Çô(t).\n\nFields\n\nintercept::R: intercept term Œ≤‚ÇÄ.\ncoefficients::Vector{R}: coefficients [Œ≤‚ÇÅ, Œ≤‚ÇÇ, ..., Œ≤‚Çô].\ncovariates::Vector{F}: covariate functions [x‚ÇÅ, x‚ÇÇ, ..., x‚Çô], each callable with signature x·µ¢(t).\n\nConstructor\n\nLinearCovariateIntensity(intercept, coefficients, covariates)\n\nExamples\n\n# With time and sin(time) as covariates\nLinearCovariateIntensity(1.0, [0.5, 2.0], [t -> t, t -> sin(t)])\n\n# With custom covariate functions\ntemp_func = t -> 20 + 5*sin(2œÄ*t/365)  # seasonal temperature\nwind_func = t -> 10 + 2*rand()          # wind speed\nLinearCovariateIntensity(0.1, [0.05, 0.02], [temp_func, wind_func])\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.from_params","page":"API reference","title":"PointProcesses.from_params","text":"from_params\n\nMethod used in optimization, where parameters are returned as vectors. Can be used to perform a transformation in the parameter space. Example:\n\nstruct Constant{R} <: ParametricIntensity\n    a::R\nend where {R<:Real}\n(f::Constant, t::Real) = f.a\n\n# Optimization procedure uses this method to calculate the objective.\n# This is not constrained to positive parameter values anymore\nfunction from_params(::Constant, params)\n    return Constant(exp(params[1]))\nend\n\n\n\n\n\nfrom_params(::Type{PolynomialIntensity{R}}, params; link=:identity)\n\nConstruct PolynomialIntensity from parameters.\n\n\n\n\n\nfrom_params(::Type{ExponentialIntensity{R}}, params)\n\nConstruct ExponentialIntensity from unconstrained parameters: params = [log(a), b].\n\n\n\n\n\nfrom_params(::Type{SinusoidalIntensity{R}}, params; œâ=2œÄ)\n\nConstruct SinusoidalIntensity from unconstrained parameters.\n\nParameters: [p‚ÇÅ, p‚ÇÇ, p‚ÇÉ] where a = exp(p‚ÇÅ), b = tanh(p‚ÇÇ)*a, œÜ = p‚ÇÉ. The œâ (angular frequency) must be specified separately.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.IntegrationConfig","page":"API reference","title":"PointProcesses.IntegrationConfig","text":"IntegrationConfig\n\nConfiguration for numerical integration of intensity functions.\n\nFields\n\nsolver: Integration solver from Integrals.jl (e.g., QuadGKJL(), HCubatureJL())\nabstol::Float64: Absolute tolerance for integration\nreltol::Float64: Relative tolerance for integration\nmaxiters::Int: Maximum number of iterations\n\nConstructor\n\nIntegrationConfig(; solver=QuadGKJL(), abstol=1e-8, reltol=1e-8, maxiters=1000)\n\nExamples\n\n# Default configuration\nconfig = IntegrationConfig()\n\n# Higher precision\nconfig = IntegrationConfig(abstol=1e-12, reltol=1e-12)\n\n# Different solver\nusing Integrals\nconfig = IntegrationConfig(solver=HCubatureJL())\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.HawkesProcess","page":"API reference","title":"PointProcesses.HawkesProcess","text":"HawkesProcess{T<:Real}\n\nUnivariate Hawkes process with exponential decay kernel.\n\nA Hawkes process is a self-exciting point process where each event increases the probability of future events. The conditional intensity function is given by:\n\nŒª(t) = Œº + Œ± ‚àë_{t·µ¢ < t} exp(-œâ(t - t·µ¢))\n\nwhere the sum is over all previous event times t·µ¢.\n\nFields\n\nŒº::T: baseline intensity (immigration rate)\nŒ±::T: jump size (immediate increase in intensity after an event)  \nœâ::T: decay rate (how quickly the excitement fades)\n\nConditions:\n\nŒº, Œ±, œâ >= 0\nœà = Œ±/œâ < 1 ‚Üí Stability condition. œà is the expected number of events each event generates\n\nFollowing the notation from (Lewis and Mohler, 2011).\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.Statistic","page":"API reference","title":"PointProcesses.Statistic","text":"Statistic\n\nInterface for all test statistics.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.statistic","page":"API reference","title":"PointProcesses.statistic","text":"statistic(::Statistic, pp::AbstractPointProcess, h::History)\n\nCompute the value of the test statistic with respect to pp and h.\n\nArguments\n\n::Statistic: The type of test statistic to be computed\npp::AbstractPointProcess: null-hypothesis model for the event history h\nh::History: the observed event history\n\nReturns\n\nFloat64: the resulting test statistic\n\nExample\n\n#=\nCalculate the Kolmogorov-Smirnov distance between the distribution of the\ntime-changed event times of `h` and a standard exponential.\n=#\nks_stat = statistic(KSDistance{Exponential}, hawkes_process, history)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.PointProcessTest","page":"API reference","title":"PointProcesses.PointProcessTest","text":"PointProcessTest\n\nInterface for all goodness-of-fit tests\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.pvalue","page":"API reference","title":"StatsAPI.pvalue","text":"pvalue(test::PointProcessTest)\n\nCalculate the p-value of a goodness-of-fit test on a process.\n\nArguments\n\n::PointProcessTest: the test result object\n\nReturns\n\nFloat64: p-value in [0, 1], where small values provide evidence against the null hypothesis\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.KSDistance","page":"API reference","title":"PointProcesses.KSDistance","text":"KSDistance{T<:UnivariateDistribution}\n\nA Kolmogorov-Smirnov distance statistic for testing goodness-of-fit of point processes against a specified distribution D after appropriate time rescaling. This test statistic is suitable only for non-marked processes, as it ignores the marks.\n\nType parameter\n\nD<:UnivariateDistribution: the target distribution to test against (e.g., Exponential, Uniform)\n\nAvailable test statistics\n\nKSDistance{Exponential}   Kolmogorov-Smirnov distance between the time-changed interevent times and a standard exponential\nKSDistance{Uniform}   Kolmogorov-Smirnov distance between the time-changed event times and a uniform distribution\n\nExample\n\nBootstrapTest(KSDistance{Exponential}, HawkesProcess, history)\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BootstrapTest","page":"API reference","title":"PointProcesses.BootstrapTest","text":"BootstrapTest <: PointProcessTest\n\nAn object containing the results of a bootstrap-based goodness-of-fit test. The p-value of the test is calculated as     p = (count(simstats ‚â• stat) + 1) / (nsims + 1).\n\nFields\n\nn_sims::Int: number of bootstrap simulations performed\nstat::Float64: observed test statistic value\nsim_stats::Vector{Float64}: test statistics from bootstrap simulations\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BootstrapTest-Tuple{Type{<:Statistic}, Type{<:AbstractPointProcess}, History}","page":"API reference","title":"PointProcesses.BootstrapTest","text":"BootstrapTest(S::Type{<:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())\n\nPerform a goodness-of-fit test using simulation with bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.\n\nIf Œª‚ÇÄ(t) is the true intensity function of the process that generated the observed history, and Œª(t; Œ∏) is a a parametrization of the intensity, then the null hypothesis is\n\nH‚ÇÄ: There exists parameters Œ∏‚Çí such that Œª‚ÇÄ(t) = Œª(t; Œ∏‚ÇÄ)\n\nThis procedure is specifically aimed for testing hypotheses where parameters need to be estimated. Details are provided in (Kling and Vetter, 2025).\n\nArguments\n\nS::Type{<:Statistic}: the type of test statistic to use\npp::Type{<:AbstractPointProcess}: the null hypothesis model family\nh::History: the observed event history\nn_sims::Int=1000: number of bootstrap simulations to perform\nrng::AbstractRNG=default_rng(): Random number generator\n\nReturns\n\nBootstrapTest: test result object containing the observed statistic, bootstrap statistics, and test metadata\n\nExample\n\n# Bootstrap test for Hawkes process model adequacy\ntest = BootstrapTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)\np = pvalue(test)\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.MonteCarloTest","page":"API reference","title":"PointProcesses.MonteCarloTest","text":"MonteCarloTest <: PointProcessTest\n\nAn object containing the results of a non-bootstrap based goodness-of-fit test. The p-value of the test is calculated as     p = (count(simstats ‚â• stat) + 1) / (nsims + 1).\n\nFields\n\nn_sims::Int: number of simulations performed\nstat::Float64: observed test statistic value\nsim_stats::Vector{Float64}: test statistics from simulated data\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MonteCarloTest-Tuple{Type{<:Statistic}, AbstractPointProcess, History}","page":"API reference","title":"PointProcesses.MonteCarloTest","text":"MonteCarloTest(S::Type{<:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())\n\nPerform a goodness-of-fit test using simulation without bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.\n\nIf Œª‚ÇÄ(t) is the true intensity function of the process that generated the observed history, and Œª(t; Œ∏) is a a parametrization of the intensity, then there are two forms for the null hypothesis:\n\n1. H‚ÇÄ: Œª‚ÇÄ(t) = Œª(t; Œ∏‚ÇÄ)\n2. H‚ÇÄ: There exists parameters Œ∏‚Çí such that Œª‚ÇÄ(t) = Œª(t; Œ∏‚ÇÄ)\n\nIf pp is an instance of an AbstractPointProcess, the null hypothesis 1 is considered, if a pp is a Type{<:AbstractPointProcess}, the method uses null hypothesis 2.\n\nNotice that this test is better suited when the parameter Œ∏‚ÇÄ is known (form 1), since this procedure does not account for parameter estimation error. For more details on this, see (Babu and Rao, 2004), (Reynaud-Bouret et al., 2014),  (Kling and Vetter, 2025).\n\nArguments\n\nS::Type{<:Statistic}: the type of test statistic to use\npp::Union{AbstractPointProcess, Type{<:AbstractPointProcess}}: the null hypothesis model family\nh::History: the observed event history\nn_sims::Int=1000: number of simulations to perform for the test\nrng::AbstractRNG=default_rng(): Random number generator\n\nReturns\n\nMonteCarloTest: test result object containing the observed statistic, simulated statistics, and test metadata\n\nExample\n\n# Test null hypothesis of form 1. Known Œ∏‚ÇÄ\ntest = MonteCarloTest(KSDistance(Exponential), HawkesProcess(1, 1, 2), history; n_sims=1000)\np = pvalue(test)\n# Test null hypothesis of form 2. Unknown Œ∏‚ÇÄ\ntest = MonteCarloTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)\np = pvalue(test)\n\n\n\n\n\n","category":"method"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"Here is a list of features that are yet to be implemented...","category":"section"},{"location":"roadmap/#Soon","page":"Roadmap","title":"Soon","text":"Compatibility with reverse-mode AD (Zygote.jl)\nHawkes processes\nCox processes\nMarkov-Modulated Poisson Processes\nPrediction and evaluation utilities","category":"section"},{"location":"roadmap/#Someday","page":"Roadmap","title":"Someday","text":"Poisson processes on arbitrary measured spaces\nPiecewise-Deterministic Markov Processes\nGaussian Process-modulated Poisson Processes","category":"section"},{"location":"roadmap/#Maybe-not","page":"Roadmap","title":"Maybe not","text":"Neural point processes?\nInterface with MLJ.jl?\nInterface with Turing.jl?","category":"section"},{"location":"examples/Basics/#The-basics-of-Point-Process-Modeling","page":"Basics","title":"The basics of Point Process Modeling","text":"This tutorial provides a brief introduction to point process modeling using PointProcesses.jl. We will cover the basic math of point processes, how to define basic models, simulate data, and fit models to observed data. For further, and more advanced pedagogy, please refer to any of the following great resources:\n\n(Daley and Vere-Jones, 2013)\n(Cox and Isham, 2018)\n\nThe focus of this tutorial is intentionally narrow: we aim to build intuition by starting with the simplest point process model and making the connection between mathematical definitions, simulation, and likelihood-based inference explicit.","category":"section"},{"location":"examples/Basics/#Basic-Point-Process-Concepts","page":"Basics","title":"Basic Point Process Concepts","text":"A point process is a mathematical model for random events occurring in time or space. In this tutorial, we focus on temporal point processes, where events are represented as a set of event times:\n\n{t‚ÇÅ, t‚ÇÇ, ‚Ä¶, t‚Çô} ‚äÇ [0, T]\n\nThe key components of a point process are:\n\nEvents: The occurrences we are modeling, represented as points in time.\nCounting Process: N(t), the number of events that have occurred up to time t.\nIntensity Function: A (possibly time- and history-dependent) function Œª(t | ùìó‚Çú) describing the instantaneous rate at which events occur.\nHistory: ùìó‚Çú, the record of events strictly before time t.\n\nIntuitively, the intensity function Œª(t | ùìó‚Çú) satisfies\n\nŒª(t | ùìó‚Çú) Œît ‚âà P(event in [t, t + Œît) | ùìó‚Çú)\n\nfor small Œît. Different choices of Œª give rise to different classes of point processes:\n\nHomogeneous Poisson process: Œª(t) = Œª (constant)\nInhomogeneous Poisson process: Œª(t) varies with time.\nHistory-dependent processes: Œª(t | ùìó‚Çú) depends on past events (e.g. Hawkes processes)","category":"section"},{"location":"examples/Basics/#The-Homogeneous-Poisson-Process","page":"Basics","title":"The Homogeneous Poisson Process","text":"The simplest and most widely used point process is the homogeneous Poisson process. It is defined by a single parameter Œª > 0, the constant event rate, and is characterized by:\n\nIndependent increments: The numbers of events in disjoint time intervals are independent.\nStationary increments: The distribution of events depends only on the length of the interval.\nOrderliness: The probability of more than one event occurring in a small interval is negligible.\n\nDespite its simplicity, the homogeneous Poisson process provides a useful baseline model and a reference point for more expressive point process models. Let's start simulating data using PointProcesses.jl\n\nusing PointProcesses\nusing Distributions\nusing HypothesisTests\nusing StatsBase\nusing Plots\n\nusing StableRNGs # hide\nrng = StableRNG(67); # hide\nnothing #hide\n\nUsually we observe some data, typically, these will be event times. Assume, we have seen the following event times, from a cultured retinal ganglion cell neuron with no input stimulus:\n\nwaiting_times = rand(rng, InverseGaussian(0.2, 0.5), 50) # hide\nevent_times = cumsum(waiting_times) # hide\n\nh = History(event_times, 0.0, maximum(event_times) + 1.0)\n\nLet's visualize our event times as a raster plot:\n\nraster = plot(;\n    xlabel=\"Time\",\n    ylabel=\"Events\",\n    title=\"Raster Plot of Event Times\",\n    ylim=(-0.1, 1),\n    yticks=false,\n)\nfor time in h.times\n    vline!([time]; color=:blue, linewidth=2, label=false)\nend\n\nraster\n\nLooking at this plot, it's difficult to tell whether the event times are consistent with a homogeneous Poisson process. We can bin the data in small time windows to get a sense of the event rate over time. From the assumptions above, we expect the distribution of counts to be roughly Poisson distributed with rate Œª * Œît in each bin of width Œît.\n\nbin_width = 1.0\nbins = collect(h.tmin:bin_width:h.tmax)           # bin edges\ncounts = fit(Histogram, h.times, bins).weights;    # counts per bin\nnothing #hide\n\nPlot counts over time (counts/bin_width is a crude rate estimate)\n\nbin_centers = (bins[1:(end - 1)] .+ bins[2:end]) ./ 2\n\np_counts = plot(\n    bin_centers,\n    counts;\n    seriestype=:bar,\n    xlabel=\"Time\",\n    ylabel=\"Count per bin\",\n    title=\"Binned event counts\",\n)\n\np_counts\n\nThis is still difficult to tell. To get a better sense of whether the data is consistent with a homogeneous Poisson process, we can consider an alternative view of the homogeneous point process based on the distribution of its waiting times. We discuss this below.","category":"section"},{"location":"examples/Basics/#Two-Equivalent-Views","page":"Basics","title":"Two Equivalent Views","text":"The homogeneous Poisson process admits two equivalent and complementary descriptions:\n\n(1) Inter-event times The waiting times between successive events are independent and identically distributed:\n\nœÑ‚Çñ = t‚Çñ - t‚Çñ‚Çã‚ÇÅ ‚àº Exponential(Œª)\n\nThis view is particularly convenient for simulation.\n\n(2) Counting process The total number of events in a time window of length T is distributed as:\n\nN(T) ‚àº Poisson(Œª T)\n\nConditioned on N(T) = n, the event times are uniformly distributed on [0, T].\n\nThese two perspectives define the same stochastic process and will both be useful for understanding likelihood-based inference.\n\nLets now calculate the waiting times and see how \"exponential\" they look:\n\nwaiting_times = diff(vcat(h.tmin, h.times));   # includes waiting time from tmin to first event\nnothing #hide\n\nT = duration(h)             # should be h.tmax - h.tmin\nn = length(h)               # number of events\nŒª_est = n / T\n\np_waiting = histogram(\n    waiting_times;\n    bins=10,\n    normalize=:pdf,\n    xlabel=\"Waiting time\",\n    ylabel=\"Density\",\n    title=\"Histogram of Waiting Times\",\n    label=\"Empirical\",\n)\n\nx = range(0; stop=maximum(waiting_times), length=400)\nplot!(\n    p_waiting,\n    x,\n    pdf.(Exponential(1 / Œª_est), x);\n    label=\"Exponential(ŒªÃÇ=$(round(Œª_est, digits=2)))\",\n    linewidth=2,\n    color=:red,\n)\n\np_waiting\n\nThis could be maybe exponential, but there is some signs that it is not. For example, why do we not see any waiting times below approximately 0.1s? Let's fit the actual model now using PointProcesses.jl and run some formal statistical tests.","category":"section"},{"location":"examples/Basics/#Fitting-a-Homogeneous-Poisson-Process","page":"Basics","title":"Fitting a Homogeneous Poisson Process","text":"pp_model = fit(PoissonProcess{Float64,Dirac{Nothing}}, h)\n\nprintln(\"Estimated rate ŒªÃÇ = \", pp_model.Œª) # hide\n\nWe can now use this fitted model to run some statistical tests to see whether the homogeneous Poisson process is a good fit to the data. First let's plot a qq-plot of the waiting times against the expected exponential distribution.\n\nq = range(0.01, 0.99; length=200)\nemp_q = quantile(waiting_times, q)\ntheo_q = quantile.(Exponential(1 / Œª_est), q)   # Exp with mean 1/Œª_est\n\npqq = plot(\n    theo_q,\n    emp_q;\n    seriestype=:scatter,\n    xlabel=\"Theoretical quantiles: Exp(mean=1/ŒªÃÇ)\",\n    ylabel=\"Empirical waiting-time quantiles\",\n    title=\"QQ plot: waiting times vs fitted exponential\",\n    aspect_ratio=:equal,\n    label=false,\n    xlim=(0, 1),\n    ylim=(0, 1),\n)\nplot!(pqq, theo_q, theo_q; label=false)  # y=x line\npqq\n\nThe QQ-plot shows some deviations from the expected exponential distribution, particularly at the lower quantiles. We can use time-rescaling to formally test the goodness-of-fit of the homogeneous Poisson process model. The time-rescaling theorem states that if we transform the event times t·µ¢ using the integrated intensity function, the transformed times should be distributed as a homogeneous Poisson process with unit rate. Luckily PointProcesses.jl provides a convenient function to do this transformation for us:\n\ntransformed_times = time_change(h, pp_model)\ntransformed_waiting_times = diff(vcat(transformed_times.tmin, transformed_times.times))\n\nUnder the null hypothesis that the data is generated by the fitted homogeneous Poisson process, these transformed waiting times should be i.i.d. Exp(1) distributed.\n\nks_test = ExactOneSampleKSTest(transformed_waiting_times, Exponential(1.0))\nprintln(\"KS test p-value: \", pvalue(ks_test)) # hide\n\nThe KS test p-value is very small, indicating that we can reject the null hypothesis that the data was generated by a homogeneous Poisson process at conventional significance levels. This suggests that the homogeneous Poisson process is not an adequate model for the observed event times. There are several possible reasons for this, including:\n\nThe event rate may not be constant over time (inhomogeneous Poisson process)\nThere may be history dependence (e.g., refractory periods, bursting)\n\nBut this is a topic for another tutorial!","category":"section"},{"location":"examples/Inhomogeneous/#Fitting-Data-to-an-Inhomogeneous-Poisson-Process-Model","page":"Inhomogeneous","title":"Fitting Data to an Inhomogeneous Poisson Process Model","text":"This tutorial demonstrates how to fit data to an inhomogeneous point process model, as well as how to develop a new model from scratch. We will generate point process data from a simulated \"Hippocampal Place Cell\" and then fit the model to the data.","category":"section"},{"location":"examples/Inhomogeneous/#A-Quick-Recap-of-Inhomogeneous-Poisson-Processes","page":"Inhomogeneous","title":"A Quick Recap of Inhomogeneous Poisson Processes","text":"An inhomogeneous Poisson process is a type of point process where the intensity function varies over time or space. The intensity function, denoted as Œª(t) for time or Œª(x) for space, describes the expected number of events per unit time or space at a given point. In the context of neural data, inhomogeneous Poisson processes are often used to model the firing rates of neurons that change in response to stimuli or other factors. Importantly, all Inhomogeneous Poisson processes have the same general likelihood function form, which is given by: L(Œª t_i) = textexp(- Œª(t) dt) *  Œª(t_i) where t_i are the observed event times. This likelihood function consists of two main components:\n\nThe exponential term textexp(- Œª(t) dt) represents the probability of observing no events in the intervals where no events were recorded.\nThe product term  Œª(t_i) accounts for the likelihood of observing events at the specific times t_i.\n\nThis general form allows for flexibility in modeling various types of inhomogeneous Poisson processes by specifying different intensity functions Œª(t).\n\nusing PointProcesses\nusing Distributions\nusing StableRNGs\nusing Plots\nusing StatsAPI\nusing SpecialFunctions: erf","category":"section"},{"location":"examples/Inhomogeneous/#Simulating-Hippocampal-Place-Cell-Data","page":"Inhomogeneous","title":"Simulating Hippocampal Place Cell Data","text":"Hippocampal place cells are neurons that fire when an animal is in a specific location. As the animal moves through space, the firing rate varies, creating an inhomogeneous Poisson process. We'll simulate data where the animal makes multiple passes through the place field.\n\nLet's create a Gaussian-like place field with peak firing at the center:\n\nfunction gaussian_place_field(t; peak_rate=20.0, center=5.0, width=1.5)\n    return peak_rate * exp(-((t - center)^2) / (2 * width^2))\nend\n\nVisualize the true intensity function:\n\nt_range = 0.0:0.01:10.0\nplot(\n    t_range,\n    gaussian_place_field.(t_range);\n    xlabel=\"Position (arbitrary units)\",\n    ylabel=\"Firing rate (Hz)\",\n    label=\"True place field\",\n    linewidth=2,\n    title=\"Hippocampal Place Cell Firing Rate\",\n)\n\nNow let's simulate spike times from this intensity function:\n\nrng = StableRNG(12345)\npp_true = InhomogeneousPoissonProcess(gaussian_place_field)\nh = simulate(rng, pp_true, 0.0, 10.0)\n\nCreate a history object for our observed data:\n\nprintln(\"Number of spikes observed: \", length(h))\n\nVisualize the spike times as a raster plot:\n\nscatter!(\n    h.times,\n    zeros(length(h));\n    marker=:vline,\n    markersize=10,\n    label=\"Observed spikes\",\n    color=:red,\n    alpha=0.6,\n)","category":"section"},{"location":"examples/Inhomogeneous/#Fitting-Parametric-Models","page":"Inhomogeneous","title":"Fitting Parametric Models","text":"Now we'll try to recover the underlying intensity function by fitting different (non-)parametric models.","category":"section"},{"location":"examples/Inhomogeneous/#1.-Piecewise-Constant-Intensity-(Histogram-Estimator)","page":"Inhomogeneous","title":"1. Piecewise Constant Intensity (Histogram Estimator)","text":"The simplest approach is to bin the data and estimate a constant rate in each bin:\n\npp_piecewise = fit(\n    InhomogeneousPoissonProcess{PiecewiseConstantIntensity{Float64},Dirac{Nothing}},\n    h,\n    20,  # number of bins\n)\n\nVisualize the fit:\n\nplot(\n    t_range,\n    gaussian_place_field.(t_range);\n    xlabel=\"Position\",\n    ylabel=\"Firing rate (Hz)\",\n    label=\"True intensity\",\n    linewidth=2,\n    title=\"Piecewise Constant Fit\",\n)\nplot!(\n    t_range,\n    pp_piecewise.intensity_function.(t_range);\n    label=\"Fitted intensity\",\n    linewidth=2,\n)\nscatter!(\n    h.times,\n    zeros(length(h.times));\n    marker=:vline,\n    markersize=10,\n    label=\"Spikes\",\n    color=:red,\n    alpha=0.6,\n)\n\n### 2. Polynomial Intensity with Log Link\n\nA polynomial model can capture smooth variations. We'll use a quadratic polynomial with log link to ensure the intensity stays positive:\n\nInitial parameter guess for a quadratic: log(Œª(t)) = a‚ÇÄ + a‚ÇÅ*t + a‚ÇÇ*t¬≤\n\ninit_params = [2.0, 0.0, -0.1]\n\npp_poly = fit(PolynomialIntensity{Float64}, h, init_params; link=:log)\n\nVisualize the polynomial fit:\n\nplot(\n    t_range,\n    gaussian_place_field.(t_range);\n    xlabel=\"Position\",\n    ylabel=\"Firing rate (Hz)\",\n    label=\"True intensity\",\n    linewidth=2,\n    title=\"Polynomial Intensity Fit (Log Link)\",\n)\nplot!(t_range, pp_poly.(t_range); label=\"Fitted intensity\", linewidth=2)\nscatter!(\n    h.times,\n    zeros(length(h.times));\n    marker=:vline,\n    markersize=10,\n    label=\"Spikes\",\n    color=:red,\n    alpha=0.6,\n)\n\nprintln(\"Fitted polynomial coefficients: \", pp_poly.coefficients)","category":"section"},{"location":"examples/Inhomogeneous/#Creating-a-Custom-Intensity-Function","page":"Inhomogeneous","title":"Creating a Custom Intensity Function","text":"For our Gaussian place field, none of the built-in parametric models are ideal given our domain expertise. But do not worry! With PointProcesses.jl, you can easily create your own custom intensity functions by defining a few methods. Let's create a custom Gaussian intensity function!\n\nFirst, we'll define the intensity function structure:\n\nstruct GaussianIntensity{R<:Real} <: ParametricIntensity\n    peak_rate::R\n    center::R\n    width::R\n\n    function GaussianIntensity(peak_rate::R, center::R, width::R) where {R<:Real}\n        if peak_rate <= 0\n            throw(ArgumentError(\"peak_rate must be positive\"))\n        end\n        if width <= 0\n            throw(ArgumentError(\"width must be positive\"))\n        end\n        return new{R}(peak_rate, center, width)\n    end\nend\n\nMake it callable:\n\nfunction (f::GaussianIntensity)(t)\n    return f.peak_rate * exp(-((t - f.center)^2) / (2 * f.width^2))\nend\n\nDefine how to construct from parameters (for optimization):\n\nfunction PointProcesses.from_params(\n    ::Type{GaussianIntensity{R}}, params::AbstractVector\n) where {R}\n    peak_rate = exp(params[1])\n    center = params[2]\n    width = exp(params[3])\n    return GaussianIntensity(peak_rate, center, width)\nend\n\nDefine analytical integration (optional but recommended for speed when possible):\n\nfunction PointProcesses.integrated_intensity(\n    f::GaussianIntensity, t_start::T, t_end::T, ::IntegrationConfig\n) where {T}\n    sqrt_2 = sqrt(2.0)\n    prefactor = f.peak_rate * f.width * sqrt(œÄ / 2)\n\n    erf_upper = erf((t_end - f.center) / (sqrt_2 * f.width))\n    erf_lower = erf((t_start - f.center) / (sqrt_2 * f.width))\n\n    return prefactor * (erf_upper - erf_lower)\nend\n\nNow fit our custom Gaussian model:\n\ninit_params_gauss = [log(15.0), 5.0, log(2.0)]  #- [log(peak), center, log(width)]\n\npp_gauss = fit(GaussianIntensity{Float64}, h, init_params_gauss)\n\nprintln(\"Fitted Gaussian parameters:\") # hide\nprintln(\"  Peak rate: \", pp_gauss.peak_rate, \" Hz\") # hide\nprintln(\"  Center: \", pp_gauss.center) # hide\nprintln(\"  Width: \", pp_gauss.width) # hide\n\nVisualize our custom Gaussian fit:\n\nplot(\n    t_range,\n    gaussian_place_field.(t_range);\n    xlabel=\"Position\",\n    ylabel=\"Firing rate (Hz)\",\n    label=\"True intensity\",\n    linewidth=2,\n    title=\"Custom Gaussian Intensity Fit\",\n    legend=:topright,\n)\nplot!(t_range, pp_gauss.(t_range); label=\"Fitted intensity\", linewidth=2, linestyle=:dash)\nscatter!(\n    h.times,\n    zeros(length(h.times));\n    marker=:vline,\n    markersize=10,\n    label=\"Spikes\",\n    color=:red,\n    alpha=0.6,\n)","category":"section"},{"location":"examples/Inhomogeneous/#Model-Comparison","page":"Inhomogeneous","title":"Model Comparison","text":"Let's compare all models by computing their negative log-likelihoods:\n\nfunction compute_nll(intensity_func, h)\n    nll = -sum(log(intensity_func(t)) for t in h.times)\n    config = IntegrationConfig()\n    nll += PointProcesses.integrated_intensity(intensity_func, h.tmin, h.tmax, config)\n    return nll\nend\n\nmodels = [\n    (\"Piecewise Constant\", pp_piecewise.intensity_function),\n    (\"Polynomial\", pp_poly),\n    (\"Gaussian (Custom)\", pp_gauss),\n]\n\nprintln(\"\\nModel Comparison (Negative Log-Likelihood):\") # hide\nprintln(\"-\" ^ 50) # hide\nfor (name, model) in models # hide\n    nll = compute_nll(model, h) # hide\n    println(\"  $name: \", round(nll; digits=2)) # hide\nend # hide","category":"section"},{"location":"examples/Inhomogeneous/#Visualizing-All-Models-Together","page":"Inhomogeneous","title":"Visualizing All Models Together","text":"plot(\n    t_range,\n    gaussian_place_field.(t_range);\n    xlabel=\"Position\",\n    ylabel=\"Firing rate (Hz)\",\n    label=\"True intensity\",\n    linewidth=3,\n    title=\"Comparison of All Fitted Models\",\n    legend=:topright,\n    color=:black,\n)\n\nplot!(\n    t_range,\n    pp_piecewise.intensity_function.(t_range);\n    label=\"Piecewise\",\n    linewidth=2,\n    alpha=0.7,\n)\nplot!(t_range, pp_poly.(t_range); label=\"Polynomial\", linewidth=2, alpha=0.7)\nplot!(\n    t_range,\n    pp_gauss.(t_range);\n    label=\"Gaussian (Custom)\",\n    linewidth=2,\n    alpha=0.7,\n    linestyle=:dash,\n)\n\nscatter!(\n    h.times,\n    zeros(length(h.times));\n    marker=:vline,\n    markersize=8,\n    label=\"Spikes\",\n    color=:red,\n    alpha=0.5,\n)\n\nFrom what we can see the PolynomialIntensity and the custom GaussianIntensity learn an isomorphic representation of the true underlying intensity function. However, the custom GaussianIntensity has the advantage of interpretability, as its parameters directly correspond to meaningful features of the place field (peak rate, center, width). This makes it easier to draw conclusions about the neuron's firing behavior based on the fitted model.","category":"section"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"Babu,¬†G.¬†J. and Rao,¬†C.¬†R. (2004). Goodness-of-Fit Tests When Parameters Are Estimated. SankhyƒÅ:¬†The¬†Indian¬†Journal¬†of¬†Statistics¬†(2003-2007) 66, 63‚Äì74. Accessed on May 5, 2023.\n\n\n\nCox,¬†D. and Isham,¬†V. (2018). Point Processes (Routledge).\n\n\n\nDaley,¬†D. and Vere-Jones,¬†D. (2013). An Introduction to the Theory of Point Processes Vol. I (Springer New York).\n\n\n\nKling,¬†J.¬†C. and Vetter,¬†M. (2025). On goodness‚Äêof‚Äêfit testing for self‚Äêexciting point processes. Scandinavian¬†Journal¬†of¬†Statistics.\n\n\n\nLaub,¬†P.¬†J.; Lee,¬†Y. and Taimre,¬†T. (2021). The Elements of Hawkes Processes (Springer International Publishing).\n\n\n\nLewis,¬†E.¬†A. and Mohler,¬†G.¬†O. (2011). A Nonparametric EM algorithm for Multiscale Hawkes Processes.\n\n\n\nRasmussen,¬†J.¬†G. (Jun 2018). Lecture Notes: Temporal Point Processes and the Conditional Intensity Function. Accessed on Jul 17, 2023.\n\n\n\nReynaud-Bouret,¬†P.; Rivoirard,¬†V.; Grammont,¬†F. and Tuleau-Malot,¬†C. (2014). Goodness-of-Fit Tests and Nonparametric Adaptive Estimation for Spike Train Analysis. The¬†Journal¬†of¬†Mathematical¬†Neuroscience 4, 3.\n\n\n\n","category":"section"},{"location":"#PointProcesses.jl","page":"Home","title":"PointProcesses.jl","text":"Welcome to the documentation of PointProcesses.jl, a package for modeling, simulation and inference with temporal point processes.\n\nwarning: PointProcesses.jl is under active development\nWhile there is lots of functionality, certain elements may not be polished, and bugs likely exist. Please report issues on GitHub.","category":"section"},{"location":"#What-are-Point-Processes?","page":"Home","title":"What are Point Processes?","text":"Briefly, point processes are statistical models of random events in time or space. Point processes are parameterized by their intensity functions, or the instantaneous rate in time. A such, these models are useful anytime one is interested in how often one would see an event (e.g., buses arriving, earthquakes occuring, neurons firing.)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install the latest release from the General registry:\n\nimport Pkg; Pkg.add(\"PointProcesses\")\n\nOr install the development version:\n\nimport Pkg; Pkg.add(url=\"https://github.com/JoseKling/PointProcesses.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Simulate-a-Poisson-Process","page":"Home","title":"Simulate a Poisson Process","text":"using PointProcesses\n\n# Create a Poisson process with intensity Œª = 5.0 events per unit time\npp = PoissonProcess(5.0)\n\n# Simulate events in the interval [0, 10]\nhistory = simulate(pp, 0.0, 10.0)\n\n# Examine the events\nevent_times(history)  # Get event timestamps\nnb_events(history)    # Count events","category":"section"},{"location":"#Fit-a-Hawkes-Process","page":"Home","title":"Fit a Hawkes Process","text":"using PointProcesses\n\n# Fit a self-exciting Hawkes process to observed data\nfitted_hawkes = fit(HawkesProcess, history)\n\n# The fitted process has parameters:\n# - Œº (mu): baseline intensity\n# - Œ± (alpha): excitation magnitude\n# - œâ (omega): decay rate","category":"section"},{"location":"#Model-Time-Varying-Intensity","page":"Home","title":"Model Time-Varying Intensity","text":"using PointProcesses\n\n# Create a process with sinusoidal intensity\nintensity_func = SinusoidalIntensity(\n    amplitude=10.0,\n    baseline=5.0,\n    frequency=2œÄ,\n    phase=0.0\n)\nipp = InhomogeneousPoissonProcess(intensity_func)\n\n# Simulate and fit to data\nsimulated = simulate(ipp, 0.0, 10.0)\nfitted_ipp = fit(InhomogeneousPoissonProcess{PolynomialIntensity{2}}, simulated)","category":"section"},{"location":"#Available-Models","page":"Home","title":"Available Models","text":"Model Description Parameters\nPoissonProcess Constant intensity (homogeneous) Œª (intensity)\nMultivariatePoissonProcess Multiple independent streams Œª·µ¢ for each dimension\nInhomogeneousPoissonProcess Time-varying intensity Œª(t) Varies by intensity function\nHawkesProcess Self-exciting (clustering) Œº, Œ±, œâ\nMarkedPoissonProcess Events with associated marks Œª, mark distribution","category":"section"},{"location":"#Parametric-Intensity-Functions","page":"Home","title":"Parametric Intensity Functions","text":"For inhomogeneous Poisson processes, choose from:\n\nPolynomialIntensity: Œª(t) = a‚ÇÄ + a‚ÇÅt + a‚ÇÇt¬≤ + ...\nExponentialIntensity: Œª(t) = a¬∑exp(b¬∑t)\nSinusoidalIntensity: Œª(t) = a + b¬∑sin(œât + œÜ)\nPiecewiseConstantIntensity: Step function (histogram)\nLinearCovariateIntensity: Log-linear with covariates","category":"section"},{"location":"#Core-Workflow","page":"Home","title":"Core Workflow","text":"# 1. Create or fit a point process model\npp = PoissonProcess(3.0)\n\n# 2. Simulate event sequences\nhistory = simulate(pp, 0.0, 100.0)\n\n# 3. Fit to observed data\nfitted_pp = fit(PoissonProcess, observed_history)\n\n# 4. Validate the model\ntest = BootstrapTest(KSDistance(Exponential), PoissonProcess, history; n_sims=1000)\npval = pvalue(test)  # p-value for goodness-of-fit","category":"section"},{"location":"#Mathematical-Background","page":"Home","title":"Mathematical Background","text":"Temporal point processes are stochastic models characterized by their conditional intensity function Œª(t|‚Ñã‚Çú), which represents the instantaneous rate of events at time t given the history ‚Ñã‚Çú of events up to that time. .\n\n(Rasmussen, Jun 2018) ‚Äì Compact introductory notes on point processes\n(Laub et al., 2021) ‚Äì More detailed, but still introductory level, material focused on Hawkes processes\n(Daley and Vere-Jones, 2013) ‚Äì Comprehensive and formal presentation of point processes ","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use PointProcesses.jl in your research, please cite:\n\n(Image: DOI)","category":"section"}]
}
