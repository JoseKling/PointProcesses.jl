var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [PointProcesses]","category":"page"},{"location":"api/#Full-docs","page":"API reference","title":"Full docs","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [PointProcesses]","category":"page"},{"location":"api/#PointProcesses.PointProcesses","page":"API reference","title":"PointProcesses.PointProcesses","text":"A package for point process modeling, simulation and inference.\n\n\n\n\n\n","category":"module"},{"location":"api/#PointProcesses.BoundedTemporalPointProcess","page":"API reference","title":"PointProcesses.BoundedTemporalPointProcess","text":"BoundedTemporalPointProcess{M,T}\n\nStore a temporal point process P with pre-defined start and end times.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.ContinuousMarkovChain","page":"API reference","title":"PointProcesses.ContinuousMarkovChain","text":"ContinuousMarkovChain\n\nContinuous-time Markov chain with finite state space.\n\nFields\n\nπ0: initial state distribution\nQ: rate matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.ContinuousMarkovChainPrior","page":"API reference","title":"PointProcesses.ContinuousMarkovChainPrior","text":"ContinuousMarkovChainPrior\n\nDefine a Dirichlet prior on the initial distribution and a Gamma prior on the transition rates from each state.\n\nFields\n\nπ0α: Dirichlet parameter\nPα: Gamma rate parameters\nPβ: Gamma shape parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.ContinuousMarkovChainStats","page":"API reference","title":"PointProcesses.ContinuousMarkovChainStats","text":"ContinuousMarkovChainStats\n\nSufficient statistics for the likelihood of a ContinuousMarkovChain.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.DiscreteMarkovChain","page":"API reference","title":"PointProcesses.DiscreteMarkovChain","text":"DiscreteMarkovChain\n\nDiscrete-time Markov chain with finite state space.\n\nFields\n\nπ0: initial state distribution.\nP: state transition matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.DiscreteMarkovChainPrior","page":"API reference","title":"PointProcesses.DiscreteMarkovChainPrior","text":"DiscreteMarkovChainPrior\n\nDefine a Dirichlet prior on the initial distribution and on the transitions from each state.\n\nFields\n\nπ0α: Dirichlet parameter for the initial distribution\nPα: Dirichlet parameters for the transition matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.DiscreteMarkovChainStats","page":"API reference","title":"PointProcesses.DiscreteMarkovChainStats","text":"DiscreteMarkovChainStats\n\nSufficient statistics for the likelihood of a DiscreteMarkovChain.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.HiddenMarkovModel","page":"API reference","title":"PointProcesses.HiddenMarkovModel","text":"HMM{TransitionsType,EmissionsType}\n\nHidden Markov Model with arbitrary transition model (must be a discrete Markov chain) and emission distributions.\n\nFields\n\ntransitions::TransitionsType: state evolution process.\nemissions::Vector{EmissionsType}: one emission distribution per state.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.History","page":"API reference","title":"PointProcesses.History","text":"History{M,T<:Real}\n\nLinear event histories with marks of type M and locations of real type T.\n\nFields\n\ntimes::Vector{T}: vector of event times\nmarks::Vector{M}: vector of event marks\ntmin::T: start time\ntmax::T: end time\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcess","page":"API reference","title":"PointProcesses.MultivariatePoissonProcess","text":"MultivariatePoissonProcess{R}\n\nHomogeneous multivariate temporal Poisson process.\n\nFields\n\nλ::Vector{R}: event rates.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.PoissonProcess","page":"API reference","title":"PointProcesses.PoissonProcess","text":"PoissonProcess{D,M,R}\n\nHomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nλ::R: event rate.\nmark_dist::D: mark distribution with sample type M.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.TemporalPointProcess","page":"API reference","title":"PointProcesses.TemporalPointProcess","text":"TemporalPointProcess{M,T}\n\nThe common supertype of all temporal point processes (i.e. point processes on the real line) with mark type M and time type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.append!-Tuple{History, History}","page":"API reference","title":"Base.append!","text":"append!(h1::History, h2::History)\n\nAdd all the events of h2 at the end of h1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{History, Any, Any}","page":"API reference","title":"Base.push!","text":"push!(h::History{M}, t::Float64, m::M)\n\nAdd event (t, m) at the end of history h.\n\n\n\n\n\n","category":"method"},{"location":"api/#DensityInterface.logdensityof-Tuple{TemporalPointProcess, History}","page":"API reference","title":"DensityInterface.logdensityof","text":"logdensityof(pp, h)\n\nCompute the log probability density function for a temporal point process pp applied to history h:\n\n    log f(h) = sum_i log lambda(t_i  h_i) - Lambda(h)\n\nThe default method uses a loop over events combined with integrated_ground_intensity, but it should be reimplemented for specific processes if faster computation is possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.duration-Tuple{History}","page":"API reference","title":"PointProcesses.duration","text":"duration(h::History)\n\nCompute the difference h.tmax - h.tmin.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.ground_intensity-Tuple{TemporalPointProcess, Any, Any}","page":"API reference","title":"PointProcesses.ground_intensity","text":"ground_intensity(pp, h, t)\n\nCompute the ground intensity for a temporal point process pp applied to history h at time t.\n\nThe ground intensity quantifies the instantaneous risk of an event with any mark occurring at time t. It can be expressed as\n\n    lambda_g(th) = sum_m in mathcal lambda(t mh)\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.ground_intensity_bound-Tuple{TemporalPointProcess, Any, Any}","page":"API reference","title":"PointProcesses.ground_intensity_bound","text":"ground_intensity_bound(pp, t, h)\n\nCompute a local upper bound on the ground intensity for a temporal point process pp applied to history h at time t.\n\nReturn a tuple of the form (B L) satisfying\n\n    forall u in t t+L) quad lambda_g(th) leq B\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.has_events","page":"API reference","title":"PointProcesses.has_events","text":"has_events(h::History, tmin=-Inf, tmax=Inf)\n\nCheck the presence of events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.integrated_ground_intensity","page":"API reference","title":"PointProcesses.integrated_ground_intensity","text":"integrated_ground_intensity(pp, h[, t])\n\nCompute the integrated ground intensity (or compensator) Lambda(th) for a temporal point process pp applied to history h:\n\n    Lambda(h) = int lambda_g(th) mathrmdt\n\nThe default method uses Quadrature.jl for numerical integration, but it should be reimplemented for specific processes if explicit integration is feasible.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.intensity-Tuple{TemporalPointProcess, Any, Any, Any}","page":"API reference","title":"PointProcesses.intensity","text":"intensity(pp, m, t, h)\n\nCompute the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\nThe conditional intensity function lambda(t m  h) quantifies the instantaneous risk  of an event with mark m occurring at time t.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.log_intensity-Tuple{TemporalPointProcess, Any, Any, Any}","page":"API reference","title":"PointProcesses.log_intensity","text":"log_intensity(pp, m, t, h)\n\nCompute the logarithm of the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.mark_distribution-Tuple{TemporalPointProcess, Any, Any}","page":"API reference","title":"PointProcesses.mark_distribution","text":"mark_distribution(pp, t, h)\n\nCompute the distribution of marks for a temporal point process pp knowing that an event takes place at time t after history h.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.max_time-Tuple{History}","page":"API reference","title":"PointProcesses.max_time","text":"max_time(h)\n\nReturn the end time of h (not the same as the last event time).\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.min_time-Tuple{History}","page":"API reference","title":"PointProcesses.min_time","text":"min_time(h)\n\nReturn the starting time of h (not the same as the first event time).\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.nb_events","page":"API reference","title":"PointProcesses.nb_events","text":"nb_events(h::History, tmin=-Inf, tmax=Inf)\n\nCount events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.randprobvec-Tuple{Any}","page":"API reference","title":"PointProcesses.randprobvec","text":"randprobvec(n)\n\nReturn a random probability distribution vector of size n.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.randtransmat-Tuple{Any}","page":"API reference","title":"PointProcesses.randtransmat","text":"randtransmat(n)\n\nReturn a stochastic matrix of size n with random transition probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.simulate_ogata-Union{Tuple{M}, Tuple{Random.AbstractRNG, TemporalPointProcess{M}, Any, Any}} where M","page":"API reference","title":"PointProcesses.simulate_ogata","text":"simulate_ogata(rng, pp, tmin, tmax)\n\nSimulate a temporal point process pp on interval [tmin, tmax) using Ogata's algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.time_change-Tuple{History, Function}","page":"API reference","title":"PointProcesses.time_change","text":"time_change(h, Λ)\n\nApply the time rescaling t mapsto Lambda(t) to history h.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.uniformprobvec-Tuple{Any}","page":"API reference","title":"PointProcesses.uniformprobvec","text":"uniformprobvec(n)\n\nReturn a uniform probability distribution vector of size n.\n\n\n\n\n\n","category":"method"},{"location":"api/#PointProcesses.uniformtransmat-Tuple{Any}","page":"API reference","title":"PointProcesses.uniformtransmat","text":"uniformtransmat(n)\n\nReturn a stochastic matrix of size n with uniform transition probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Here is a list of features that are yet to be implemented...","category":"page"},{"location":"roadmap/#Soon","page":"Roadmap","title":"Soon","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Compatibility with reverse-mode AD (Zygote.jl)\nHawkes processes\nCox processes\nMarkov-Modulated Poisson Processes\nPrediction and evaluation utilities","category":"page"},{"location":"roadmap/#Someday","page":"Roadmap","title":"Someday","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Poisson processes on arbitrary measured spaces\nPiecewise-Deterministic Markov Processes\nGaussian Process-modulated Poisson Processes","category":"page"},{"location":"roadmap/#Maybe-not","page":"Roadmap","title":"Maybe not","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Neural point processes?\nInterface with MLJ.jl?\nInterface with Turing.jl?","category":"page"},{"location":"#PointProcesses.jl","page":"Home","title":"PointProcesses.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of PointProcesses.jl.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the latest release available in the General registry, run the following code in Julia's REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"PointProcesses\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the current development version, run this code instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"https://github.com/gdalle/PointProcesses.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to get started with code examples, take a look at the Tutorials section. The objects and functions defined in this package are documented in the API reference.","category":"page"}]
}
