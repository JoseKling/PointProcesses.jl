var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"PointProcesses","category":"page"},{"location":"api/#PointProcesses","page":"API reference","title":"PointProcesses","text":"PointProcesses\n\nA package for temporal point process modeling, simulation and inference.\n\n\n\n\n\n","category":"module"},{"location":"api/#Histories","page":"API reference","title":"Histories","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"History","category":"page"},{"location":"api/#PointProcesses.History","page":"API reference","title":"PointProcesses.History","text":"History{M,T<:Real}\n\nLinear event histories with marks of type M and temporal locations of type T.\n\nFields\n\ntimes::Vector{T}: sorted vector of event times\nmarks::Vector{M}: associated vector of event marks\ntmin::T: start time\ntmax::T: end time\n\n\n\n\n\n","category":"type"},{"location":"api/#Analysis","page":"API reference","title":"Analysis","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"event_marks\nevent_times\nmin_time\nmax_time\nnb_events\nhas_events\nBase.length\nduration\nmin_mark\nmax_mark","category":"page"},{"location":"api/#PointProcesses.event_marks","page":"API reference","title":"PointProcesses.event_marks","text":"event_marks(h)\n\nReturn the vector of event marks for h, sorted according to their event times.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.event_times","page":"API reference","title":"PointProcesses.event_times","text":"event_times(h)\n\nReturn the sorted vector of event times for h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_time","page":"API reference","title":"PointProcesses.min_time","text":"min_time(h)\n\nReturn the starting time of h (not the same as the first event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_time","page":"API reference","title":"PointProcesses.max_time","text":"max_time(h)\n\nReturn the end time of h (not the same as the last event time).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.nb_events","page":"API reference","title":"PointProcesses.nb_events","text":"nb_events(h)\n\nCount events in h.\n\n\n\n\n\nnb_events(h, tmin, tmax)\n\nCount events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.has_events","page":"API reference","title":"PointProcesses.has_events","text":"has_events(h)\n\nCheck the presence of events in h.\n\n\n\n\n\nhas_events(h, tmin, tmax)\n\nCheck the presence of events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API reference","title":"Base.length","text":"length(h)\n\nAlias for nb_events(h).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.duration","page":"API reference","title":"PointProcesses.duration","text":"duration(h)\n\nCompute the difference h.tmax - h.tmin.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.min_mark","page":"API reference","title":"PointProcesses.min_mark","text":"min_mark(h; [init])\n\nReturn the smallest event mark if it is smaller than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.max_mark","page":"API reference","title":"PointProcesses.max_mark","text":"max_mark(h; [init])\n\nReturn the largest event mark if it is larger than init, and init otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Modification","page":"API reference","title":"Modification","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"push!\nappend!\ntime_change\nsplit_into_chunks","category":"page"},{"location":"api/#Base.push!","page":"API reference","title":"Base.push!","text":"push!(h, t, m)\n\nAdd event (t, m) at the end of history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.append!","page":"API reference","title":"Base.append!","text":"append!(h1, h2)\n\nAdd all the events of h2 at the end of h1.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.time_change","page":"API reference","title":"PointProcesses.time_change","text":"time_change(h, Λ)\n\nApply the time rescaling t -> Λ(t) to history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.split_into_chunks","page":"API reference","title":"PointProcesses.split_into_chunks","text":"split_into_chunks(h, chunk_duration)\n\nSplit h into a vector of consecutive histories with individual duration chunk_duration.\n\n\n\n\n\n","category":"function"},{"location":"api/#Point-processes","page":"API reference","title":"Point processes","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractPointProcess\nBoundedPointProcess","category":"page"},{"location":"api/#PointProcesses.AbstractPointProcess","page":"API reference","title":"PointProcesses.AbstractPointProcess","text":"AbstractPointProcess\n\nCommon interface for all temporal point processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.BoundedPointProcess","page":"API reference","title":"PointProcesses.BoundedPointProcess","text":"BoundedPointProcess{P,T} <: AbstractPointProcess{}\n\nTemporal point process P with pre-defined start and end times.\n\nImplements some fallbacks for the AbstractPointProcess interface which accept fewer arguments.\n\nFields\n\npp::P: underlying point process\ntmin::T: start time\ntmax::T: end time\n\n\n\n\n\n","category":"type"},{"location":"api/#Intensity","page":"API reference","title":"Intensity","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"intensity\nground_intensity\nlog_intensity","category":"page"},{"location":"api/#PointProcesses.intensity","page":"API reference","title":"PointProcesses.intensity","text":"intensity(pp, m, t, h)\n\nCompute the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\nThe conditional intensity function λ(t,m|h) quantifies the instantaneous risk of an event with mark m occurring at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity","page":"API reference","title":"PointProcesses.ground_intensity","text":"ground_intensity(pp, h, t)\n\nCompute the ground intensity for a temporal point process pp applied to history h at time t.\n\nThe ground intensity quantifies the instantaneous risk of an event with any mark occurring at time t after history h:\n\nλg(t|h) = Σₘ λ(t,m|h)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.log_intensity","page":"API reference","title":"PointProcesses.log_intensity","text":"log_intensity(pp, m, t, h)\n\nCompute the logarithm of the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\n\n\n\n\n","category":"function"},{"location":"api/#Marks","page":"API reference","title":"Marks","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"mark_distribution","category":"page"},{"location":"api/#PointProcesses.mark_distribution","page":"API reference","title":"PointProcesses.mark_distribution","text":"mark_distribution(pp, t, h)\n\nCompute the distribution of marks for a temporal point process pp knowing that an event takes place at time t after history h.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation","page":"API reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"simulate_ogata\nBase.rand","category":"page"},{"location":"api/#PointProcesses.simulate_ogata","page":"API reference","title":"PointProcesses.simulate_ogata","text":"simulate_ogata(rng, pp, tmin, tmax)\n\nSimulate a temporal point process pp on interval [tmin, tmax) using Ogata's algorithm.\n\nTechnical Remark\n\nTo infer the type of the marks, the implementation assumes that there is method of mark_distribution without the argument h such that it corresponds to the distribution of marks in case the history is empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.rand","page":"API reference","title":"Base.rand","text":"rand([rng,] pp, tmin, tmax)\n\nAlias for simulate_ogata.\n\n\n\n\n\nrand([rng,], bpp::BoundedPointProcess)\n\nSimulate a point process on a predefined time interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#Inference","page":"API reference","title":"Inference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"logdensityof","category":"page"},{"location":"api/#DensityInterface.logdensityof","page":"API reference","title":"DensityInterface.logdensityof","text":"logdensityof(pp, h)\n\nCompute the log probability density function for a temporal point process pp applied to history h:\n\nℓ(h) = Σₖ log λ(tₖ|hₖ) - Λ(h)\n\nThe default method uses a loop over events combined with integrated_ground_intensity, but it should be reimplemented for specific processes if faster computation is possible.\n\n\n\n\n\n","category":"function"},{"location":"api/#Learning","page":"API reference","title":"Learning","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"integrated_ground_intensity\nground_intensity_bound\nfit\nfit_map","category":"page"},{"location":"api/#PointProcesses.integrated_ground_intensity","page":"API reference","title":"PointProcesses.integrated_ground_intensity","text":"integrated_ground_intensity(pp, h, a, b)\n\nCompute the integrated ground intensity (or compensator) Λ(t|h) for a temporal point process pp applied to history h on interval [a, b):\n\nΛ(h) = ∫ λg(t|h) dt\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.ground_intensity_bound","page":"API reference","title":"PointProcesses.ground_intensity_bound","text":"ground_intensity_bound(pp, t, h)\n\nCompute a local upper bound on the ground intensity for a temporal point process pp applied to history h at time t.\n\nReturn a tuple of the form (B, L) satisfying λg(t|h) ≤ B for all u ∈ [t, t+L).\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.fit","page":"API reference","title":"StatsAPI.fit","text":"fit(::Type{PP}, h)\nfit(::Type{PP}, histories)\n\nFit a point process of type PP to one or several histories.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointProcesses.fit_map","page":"API reference","title":"PointProcesses.fit_map","text":"fit_map(::Type{PP}, h, prior)\nfit_map(::Type{PP}, histories, prior)\n\nFit a point process of type PP to one or several histories using maximum a posteriori with a prior.\n\nNot implemented by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#Poisson-processes","page":"API reference","title":"Poisson processes","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractPoissonProcess","category":"page"},{"location":"api/#PointProcesses.AbstractPoissonProcess","page":"API reference","title":"PointProcesses.AbstractPoissonProcess","text":"AbstractPoissonProcess <: AbstractPointProcess\n\nCommon interface for all temporal Poisson processes, that is, temporal point processes for which the intensity is not a function of past history.\n\nImplements some fallbacks for the AbstractPointProcess interface which accept fewer arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Multivariate","page":"API reference","title":"Multivariate","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"MultivariatePoissonProcess\nMultivariatePoissonProcessPrior","category":"page"},{"location":"api/#PointProcesses.MultivariatePoissonProcess","page":"API reference","title":"PointProcesses.MultivariatePoissonProcess","text":"MultivariatePoissonProcess{R}\n\nMultivariate homogeneous temporal Poisson process.\n\nFields\n\nλ::Vector{R}: event rates.\n\n\n\n\n\n","category":"type"},{"location":"api/#PointProcesses.MultivariatePoissonProcessPrior","page":"API reference","title":"PointProcesses.MultivariatePoissonProcessPrior","text":"MultivariatePoissonProcessPrior{R1,R2}\n\nGamma prior on all the event rates of a MultivariatePoissonProcess.\n\nFields\n\nλ_α::Vector{R1}\nλ_β::R2\n\n\n\n\n\n","category":"type"},{"location":"api/#Marked","page":"API reference","title":"Marked","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"MarkedPoissonProcess","category":"page"},{"location":"api/#PointProcesses.MarkedPoissonProcess","page":"API reference","title":"PointProcesses.MarkedPoissonProcess","text":"MarkedPoissonProcess{R,D}\n\nHomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nλ::R: event rate.\nmark_dist::D: mark distribution.\n\nConstructor\n\nMarkedPoissonProcess(λ, mark_dist)\n\n\n\n\n\n","category":"type"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [PointProcesses]","category":"page"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Here is a list of features that are yet to be implemented...","category":"page"},{"location":"roadmap/#Soon","page":"Roadmap","title":"Soon","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Compatibility with reverse-mode AD (Zygote.jl)\nHawkes processes\nCox processes\nMarkov-Modulated Poisson Processes\nPrediction and evaluation utilities","category":"page"},{"location":"roadmap/#Someday","page":"Roadmap","title":"Someday","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Poisson processes on arbitrary measured spaces\nPiecewise-Deterministic Markov Processes\nGaussian Process-modulated Poisson Processes","category":"page"},{"location":"roadmap/#Maybe-not","page":"Roadmap","title":"Maybe not","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Neural point processes?\nInterface with MLJ.jl?\nInterface with Turing.jl?","category":"page"},{"location":"#PointProcesses.jl","page":"Home","title":"PointProcesses.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of PointProcesses.jl, a package for modeling, simulation and inference with temporal point processes.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the latest release available in the General registry, run the following code in Julia's REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"PointProcesses\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the current development version, run this code instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/gdalle/PointProcesses.jl\")","category":"page"},{"location":"#Mathematical-background","page":"Home","title":"Mathematical background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Temporal point processes are a way to describe collections of events with time stamps. Please refer to the tutorial (Rasmussen, Jun 2018) for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rasmussen, J. G. (Jun 2018). Lecture Notes: Temporal Point Processes and the Conditional Intensity Function. Accessed on Jul 17, 2023, arXiv:1806.00221 [stat].\n\n\n\n","category":"page"}]
}
