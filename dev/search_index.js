var documenterSearchIndex = {"docs":
[{"location":"history/#Event-history","page":"Event history","title":"Event history","text":"","category":"section"},{"location":"history/","page":"Event history","title":"Event history","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"history/abstract.jl\"]","category":"page"},{"location":"history/#PointProcesses.AbstractHistory","page":"Event history","title":"PointProcesses.AbstractHistory","text":"AbstractHistory{L, M}\n\nAbstract supertype for event histories with locations of type L and marks of type M.\n\n\n\n\n\n","category":"type"},{"location":"history/","page":"Event history","title":"Event history","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"history/temporal.jl\"]","category":"page"},{"location":"history/#PointProcesses.TemporalHistory","page":"Event history","title":"PointProcesses.TemporalHistory","text":"TemporalHistory{M}\n\nLinear event histories with marks of type M.\n\nFields\n\ntimes::Vector{Float64}: vector of event times\nmarks::Vector{M}: vector of event marks\ntmin::Float64: start time\ntmax::Float64: end time\n\n\n\n\n\n","category":"type"},{"location":"history/#Base.push!-Tuple{TemporalHistory, Any, Any}","page":"Event history","title":"Base.push!","text":"push!(h::TemporalHistory{M}, t::Float64, m::M)\n\nAdd event (t, m) at the end of history h.\n\n\n\n\n\n","category":"method"},{"location":"history/#PointProcesses.duration-Tuple{TemporalHistory}","page":"Event history","title":"PointProcesses.duration","text":"duration(h::TemporalHistory)\n\nCompute the difference h.tmax - h.tmin.\n\n\n\n\n\n","category":"method"},{"location":"history/#PointProcesses.has_events","page":"Event history","title":"PointProcesses.has_events","text":"has_events(h::TemporalHistory, tmin=-Inf, tmax=Inf)\n\nCheck the presence of events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"history/#PointProcesses.nb_events","page":"Event history","title":"PointProcesses.nb_events","text":"nb_events(h::TemporalHistory, tmin=-Inf, tmax=Inf)\n\nCount events in h during the interval [tmin, tmax).\n\n\n\n\n\n","category":"function"},{"location":"history/#PointProcesses.time_change-Tuple{TemporalHistory, Any}","page":"Event history","title":"PointProcesses.time_change","text":"time_change(h, Λ)\n\nApply the time rescaling t mapsto Lambda(t) to history h.\n\n\n\n\n\n","category":"method"},{"location":"models/#Point-process-models","page":"Built-in models","title":"Point process models","text":"","category":"section"},{"location":"models/#Temporal-processes","page":"Built-in models","title":"Temporal processes","text":"","category":"section"},{"location":"models/#Poisson-processes","page":"Built-in models","title":"Poisson processes","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"models/poisson.jl\", \"models/poisson_inhomogeneous.jl\"]","category":"page"},{"location":"models/#PointProcesses.PoissonProcess","page":"Built-in models","title":"PointProcesses.PoissonProcess","text":"PoissonProcess{R<:Real,D,M}\n\nHomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nλ::R: event rate.\nmark_dist: mark distribution.\n\n\n\n\n\n","category":"type"},{"location":"models/#PointProcesses.InhomogeneousPoissonProcess","page":"Built-in models","title":"PointProcesses.InhomogeneousPoissonProcess","text":"InhomogeneousPoissonProcess{D,M}\n\nInhomogeneous temporal Poisson process with arbitrary mark distribution.\n\nFields\n\nλ::Function: intensity function.\nmark_dist::D: mark distribution.\n\n\n\n\n\n","category":"type"},{"location":"models/#Multivariate-processes","page":"Built-in models","title":"Multivariate processes","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"models/poisson_multivariate.jl\", \"models/poisson_multivariate_naive.jl\", \"models/hawkes.jl\"]","category":"page"},{"location":"models/#PointProcesses.MultivariatePoissonProcess","page":"Built-in models","title":"PointProcesses.MultivariatePoissonProcess","text":"MultivariatePoissonProcess{R}\n\nHomogeneous temporal multivariate Poisson process.\n\nFields\n\nλ::Vector{R}: event rates.\n\n\n\n\n\n","category":"type"},{"location":"models/#PointProcesses.NaiveMultivariatePoissonProcess","page":"Built-in models","title":"PointProcesses.NaiveMultivariatePoissonProcess","text":"NaiveMultivariatePoissonProcess{R}\n\nHomogeneous temporal multivariate Poisson process.\n\nThis naive implementation demonstrates the use of our general TemporalPointProcess interface.\n\nFields\n\nλ::Vector{R}: event rates.\n\n\n\n\n\n","category":"type"},{"location":"models/#PointProcesses.MultivariateHawkesProcess","page":"Built-in models","title":"PointProcesses.MultivariateHawkesProcess","text":"MultivariateHawkesProcess{R}\n\nHomogeneous temporal multivariate Hawkes process.\n\nFields\n\nλ::Vector{R}: base event rates\nα::Matrix{R}: excitation amplitudes\nβ::Matrix{R}: excitation decays\n\n\n\n\n\n","category":"type"},{"location":"models/#Spatial-processes","page":"Built-in models","title":"Spatial processes","text":"","category":"section"},{"location":"models/#Spatio-temporal-processes","page":"Built-in models","title":"Spatio-temporal processes","text":"","category":"section"},{"location":"point_processes/#Point-processes","page":"General functions","title":"Point processes","text":"","category":"section"},{"location":"point_processes/","page":"General functions","title":"General functions","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"point_processes/abstract.jl\"]","category":"page"},{"location":"point_processes/#PointProcesses.AbstractPointProcess","page":"General functions","title":"PointProcesses.AbstractPointProcess","text":"AbstractPointProcess{L, M}\n\nThe common supertype of all point processes with location type L and mark type M.\n\n\n\n\n\n","category":"type"},{"location":"point_processes/#PointProcesses.build_transform","page":"General functions","title":"PointProcesses.build_transform","text":"build_transform(pp)\n\nReturn a transformation object from TransformVariables that can turn a Vector{Float64} into a NamedTuple with fields matching those of pp.\n\n\n\n\n\n","category":"function"},{"location":"point_processes/#Temporal-point-processes","page":"General functions","title":"Temporal point processes","text":"","category":"section"},{"location":"point_processes/","page":"General functions","title":"General functions","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"point_processes/temporal.jl\"]","category":"page"},{"location":"point_processes/#PointProcesses.BoundedTemporalPointProcess","page":"General functions","title":"PointProcesses.BoundedTemporalPointProcess","text":"BoundedTemporalPointProcess{L<:Real, M}\n\nStore a temporal point process P with pre-defined start and end times.\n\n\n\n\n\n","category":"type"},{"location":"point_processes/#PointProcesses.TemporalPointProcess","page":"General functions","title":"PointProcesses.TemporalPointProcess","text":"TemporalPointProcess{L<:Real, M}\n\nThe common supertype of all temporal point processes (i.e. point processes on the real line) with mark type M.\n\n\n\n\n\n","category":"type"},{"location":"point_processes/#Intensity-functions","page":"General functions","title":"Intensity functions","text":"","category":"section"},{"location":"point_processes/","page":"General functions","title":"General functions","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"point_processes/intensity.jl\"]","category":"page"},{"location":"point_processes/#PointProcesses.ground_intensity-Tuple{TemporalPointProcess, TemporalHistory, Any}","page":"General functions","title":"PointProcesses.ground_intensity","text":"ground_intensity(pp, h, t)\n\nCompute the ground intensity for a temporal point process pp applied to history h at time t.\n\nThe ground intensity quantifies the instantaneous risk of an event with any mark occurring at time t[Rasmussen_2018]. It can be expressed as\n\n    lambda_g(th) = sum_m in mathcal lambda(t mh)\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#PointProcesses.ground_intensity_bound-Tuple{TemporalPointProcess, TemporalHistory, Any}","page":"General functions","title":"PointProcesses.ground_intensity_bound","text":"ground_intensity_bound(pp, θ, h, t)\n\nCompute a local upper bound on the ground intensity for a temporal point process pp applied to history h at time t[Rasmussen_2018].\n\nReturn a tuple of the form (B L) satisfying\n\n    forall u in t t+L) quad lambda_g(th) leq B\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#PointProcesses.intensity-Tuple{TemporalPointProcess, TemporalHistory, Any, Any}","page":"General functions","title":"PointProcesses.intensity","text":"intensity(pp, h, t, m)\n\nCompute the conditional intensity for a temporal point process pp applied to history h and event (t, m).\n\nThe conditional intensity function lambda(t m  h) quantifies the instantaneous risk  of an event with mark m occurring at time t[Rasmussen_2018].\n\n[Rasmussen_2018]: Rasmussen, J. G. (2018), “Lecture Notes: Temporal Point Processes and the Conditional Intensity Function,” arXiv:1806.00221 [stat].\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#PointProcesses.mark_distribution-Tuple{TemporalPointProcess, TemporalHistory, Any}","page":"General functions","title":"PointProcesses.mark_distribution","text":"mark_distribution(pp, h, t)\n\nCompute the distribution of marks for a temporal point process pp knowing that an event takes place at time t after history h.\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#Simulation","page":"General functions","title":"Simulation","text":"","category":"section"},{"location":"point_processes/","page":"General functions","title":"General functions","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"point_processes/ogata.jl\"]","category":"page"},{"location":"point_processes/#Base.rand-Union{Tuple{M}, Tuple{Random.AbstractRNG, TemporalPointProcess{M}, Any, Any}} where M","page":"General functions","title":"Base.rand","text":"rand(rng, pp, tmin, tmax)\n\nSimulate a temporal point process pp on interval [tmin, tmax) using Ogata's algorithm[Ogata_1981].\n\n[Ogata_1981]: Ogata, Y. (1981), “On Lewis’ simulation method for point processes,” IEEE Transactions on Information Theory, 27, 23–31. https://doi.org/10.1109/TIT.1981.1056305.\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#Learning","page":"General functions","title":"Learning","text":"","category":"section"},{"location":"point_processes/","page":"General functions","title":"General functions","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"point_processes/learning.jl\"]","category":"page"},{"location":"point_processes/#Distributions.logpdf-Tuple{TemporalPointProcess, TemporalHistory}","page":"General functions","title":"Distributions.logpdf","text":"logpdf(pp, h)\n\nCompute the log probability density function for a temporal point process pp applied to history h:\n\n    log f(h) = sum_i log lambda(t_i  h_i) - Lambda(h)\n\nThe default method uses a loop over events combined with integrated_ground_intensity, but it should be reimplemented for specific processes if faster computation is possible.\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#PointProcesses.check_residuals-Tuple{TemporalPointProcess, TemporalHistory}","page":"General functions","title":"PointProcesses.check_residuals","text":"check_residuals(pp, h)\n\nCheck whether the point process pp is a good fit for history h by applying Ogata's time rescaling method: if (t_i)_i is a temporal point process with intensity lambda(t), then (Lambda(t_i))_i is a standard temporal Poisson process.\n\n\n\n\n\n","category":"method"},{"location":"point_processes/#PointProcesses.integrated_ground_intensity","page":"General functions","title":"PointProcesses.integrated_ground_intensity","text":"integrated_ground_intensity(pp, h[, t])\n\nCompute the integrated ground intensity (or compensator) Lambda(th) for a temporal point process pp applied to history h:\n\n    Lambda(h) = int lambda_g(th) mathrmdt\n\nThe default method uses Quadrature.jl for numerical integration, but it should be reimplemented for specific processes if explicit integration is feasible.\n\n\n\n\n\n","category":"function"},{"location":"point_processes/#StatsBase.fit-Union{Tuple{PP}, Tuple{M}, Tuple{PP, TemporalHistory{M}}} where {M, PP<:TemporalPointProcess}","page":"General functions","title":"StatsBase.fit","text":"fit(pp0, h)\n\nCompute the optimal parameter for a temporal point process of type typeof(pp0) on history h using maximum likelihood:\n\n    hattheta = mathrmargmax f_theta(h) theta in Theta\n\nThe default method uses GalacticOptim.jl for numerical optimization, but it should be reimplemented for specific processes if explicit maximization is feasible.\n\n\n\n\n\n","category":"method"},{"location":"list/#List-of-exports","page":"Index","title":"List of exports","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"","category":"page"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Here is a list of features that are yet to be implemented...","category":"page"},{"location":"roadmap/#Soon","page":"Roadmap","title":"Soon","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Compatibility with reverse-mode AD (Zygote.jl)\n[ ] Hawkes processes\n[ ] Cox processes\n[ ] Markov-Modulated Poisson Processes\n[ ] Prediction and evaluation utilities","category":"page"},{"location":"roadmap/#Someday","page":"Roadmap","title":"Someday","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Poisson processes on arbitrary measured spaces","category":"page"},{"location":"roadmap/#Maybe-not","page":"Roadmap","title":"Maybe not","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Neural point processes?\n[ ] Interface with MLJ.jl?\n[ ] Interface with Turing.jl?","category":"page"},{"location":"hmm/#Hidden-Markov-models","page":"Hidden Markov models","title":"Hidden Markov models","text":"","category":"section"},{"location":"hmm/","page":"Hidden Markov models","title":"Hidden Markov models","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"hmm/hmm.jl\", \"hmm/forward_backward.jl\", \"hmm/baum_welch.jl\"]","category":"page"},{"location":"hmm/#PointProcesses.HiddenMarkovModel","page":"Hidden Markov models","title":"PointProcesses.HiddenMarkovModel","text":"HiddenMarkovModel{Tr<:DiscreteMarkovChain,Em}\n\nHidden Markov Model with arbitrary transition model (must be a discrete Markov chain) and emission distributions.\n\nFields\n\ntransitions::Tr: state evolution process.\nemissions::Vector{Em}: one emission distribution per state.\n\n\n\n\n\n","category":"type"},{"location":"markov/#Markov-chains","page":"Markov chains","title":"Markov chains","text":"","category":"section"},{"location":"markov/","page":"Markov chains","title":"Markov chains","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"markov/abstract.jl\"]","category":"page"},{"location":"markov/","page":"Markov chains","title":"Markov chains","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"markov/discrete_time.jl\"]","category":"page"},{"location":"markov/#PointProcesses.DiscreteMarkovChain","page":"Markov chains","title":"PointProcesses.DiscreteMarkovChain","text":"DiscreteMarkovChain{R<:Real}\n\nDiscrete-time Markov chain.\n\nFields\n\nπ0::Vector{R}: initial state distribution\nP::Matrix{R}: state transition matrix.\n\n\n\n\n\n","category":"type"},{"location":"markov/#PointProcesses.DiscreteMarkovChainStats","page":"Markov chains","title":"PointProcesses.DiscreteMarkovChainStats","text":"ContinuousMarkovChainStats\n\nSufficient statistics for the likelihood of a ContinuousMarkovChain.\n\n\n\n\n\n","category":"type"},{"location":"markov/","page":"Markov chains","title":"Markov chains","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"markov/continuous_time.jl\"]","category":"page"},{"location":"markov/#PointProcesses.ContinuousMarkovChain","page":"Markov chains","title":"PointProcesses.ContinuousMarkovChain","text":"ContinuousMarkovChain{R<:Real}\n\nContinuous-time Markov chain.\n\nFields\n\nπ0::Vector{R}: initial state distribution\nQ::Matrix{R}: rate matrix.\n\n\n\n\n\n","category":"type"},{"location":"markov/#PointProcesses.ContinuousMarkovChainStats","page":"Markov chains","title":"PointProcesses.ContinuousMarkovChainStats","text":"ContinuousMarkovChainStats\n\nSufficient statistics for the likelihood of a ContinuousMarkovChain.\n\n\n\n\n\n","category":"type"},{"location":"#PointProcesses","page":"Home","title":"PointProcesses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of PointProcesses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PointProcesses","category":"page"},{"location":"#PointProcesses","page":"Home","title":"PointProcesses","text":"A package for point process modeling, simulation and inference.\n\n\n\n\n\n","category":"module"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started, take a look at the Tutorial.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using PointProcesses\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial we demonstrate the main features of PointProcesses.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Random\n\njulia> using Distributions\n\njulia> Random.seed!(63);","category":"page"},{"location":"tutorial/#Working-with-event-histories","page":"Tutorial","title":"Working with event histories","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To analyze point processes, we need a way to store their realizations. This is the purpose of the AbstractHistory subtypes, of which only TemporalHistory is implemented for now.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> history = TemporalHistory([0.2, 0.8, 1.1], [\"a\", \"b\", \"c\"], 0.0, 2.0);\n\njulia> duration(history)\n2.0\n\njulia> nb_events(history)\n3\n\njulia> nb_events(history, 1.0, 2.0)\n1\n\njulia> has_events(history)\ntrue\n\njulia> has_events(history, 1.5, 2.0)\nfalse\n\njulia> push!(history, 1.7, \"d\")\n\njulia> has_events(history, 1.5, 2.0)\ntrue","category":"page"},{"location":"tutorial/#Working-with-Markov-processes","page":"Tutorial","title":"Working with Markov processes","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some point processes are based on underlying Markov processes, which is why we provide a basic implementation for them.","category":"page"},{"location":"tutorial/#Discrete-time-Markov-chains","page":"Tutorial","title":"Discrete time Markov chains","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dmc = DiscreteMarkovChain(π0 = [0.3, 0.7], P = [0.9 0.1; 0.2 0.8]);\n\njulia> states = rand(dmc, 1000);\n\njulia> dmc_est = fit(DiscreteMarkovChain, states);\n\njulia> round.(dmc_est.P, digits=1)\n2×2 Matrix{Float64}:\n 0.9  0.1\n 0.2  0.8","category":"page"},{"location":"tutorial/#Continuous-time-Markov-chains","page":"Tutorial","title":"Continuous time Markov chains","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> cmc = ContinuousMarkovChain(π0 = [0.3, 0.7], Q = [-1. 1.; 2. -2.]);\n\njulia> history = rand(cmc, 0., 1000.);\n\njulia> cmc_est = fit(ContinuousMarkovChain, history);\n\njulia> round.(cmc_est.Q, digits=1)\n2×2 Matrix{Float64}:\n -1.0   1.0\n  1.9  -1.9","category":"page"},{"location":"tutorial/#Hidden-Markov-models","page":"Tutorial","title":"Hidden Markov models","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> hmm = HiddenMarkovModel(\n           transitions = dmc,\n           emissions = [Normal(1, 0.3), Normal(2, 0.3)]\n       )\nHiddenMarkovModel{DiscreteMarkovChain{Float64}, Normal{Float64}}\n  transitions: DiscreteMarkovChain{Float64}\n  emissions: Array{Normal{Float64}}((2,))\n\njulia> states, observations = rand(hmm, 1000);\n\njulia> hmm_init = HiddenMarkovModel(\n           transitions = DiscreteMarkovChain(π0 = randprobvec(2), P = randtransmat(2)),\n           emissions = [Normal(rand(), 1), Normal(rand(), 1)]\n       );\n\njulia> hmm_est, logL_evolution = baum_welch(hmm_init, observations, iter=100);\n\njulia> minimum(diff(logL_evolution))\n-8.185452315956354e-12\n\njulia> round.(transition_matrix(hmm_est), digits=2)\n2×2 Matrix{Float64}:\n 0.83  0.17\n 0.11  0.89\n\njulia> emissions(hmm_est)\n2-element Vector{Normal{Float64}}:\n Distributions.Normal{Float64}(μ=2.007774167238364, σ=0.28677264095786803)\n Distributions.Normal{Float64}(μ=0.9764685756929417, σ=0.30552164217241995)","category":"page"},{"location":"tutorial/#Working-with-temporal-point-processes","page":"Tutorial","title":"Working with temporal point processes","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We finally demonstrate the main goal of the package: point process simulation and inference. All point processes are subtypes of AbstractPointProcess{L,M}, where L is the type of event locations and M is the type of event marks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We provide a number of built-in models, starting with basic Poisson processes on the real line.","category":"page"},{"location":"tutorial/#Multivariate-Poisson-processes","page":"Tutorial","title":"Multivariate Poisson processes","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> pp = MultivariatePoissonProcess(λ = [0.5, 1., 2.]);\n\njulia> history = rand(pp, 0., 1000.);\n\njulia> pp_est = fit(MultivariatePoissonProcess, history);\n\njulia> round.(pp_est.λ, digits=1)\n3-element Vector{Float64}:\n 0.5\n 1.0\n 2.0","category":"page"},{"location":"tutorial/#General-Poisson-processes","page":"Tutorial","title":"General Poisson processes","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Todo","category":"page"},{"location":"tutorial/#Implementing-your-own-models","page":"Tutorial","title":"Implementing your own models","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To implement your own process, you only have to define a subtype of TemporalPointProcess and write the necessary methods: intensity, mark_distribution, ground_intensity and ground_intensity_bound.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As long as these methods exist, the default simulation and inference routines should work, but they can be made much more efficient using custom implementations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, we included a naive re-implementation of  MultivariatePoissonProcess, called NaiveMultivariatePoissonProcess. Looking at its source may help you understand the requirements of the interface.","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [PointProcesses]\nOrder = [:type, :function]\nPages = [\"utils/plot.jl\", \"utils/utils.jl\"]","category":"page"}]
}
