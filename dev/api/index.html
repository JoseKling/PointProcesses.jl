<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · PointProcesses.jl</title><meta name="title" content="API reference · PointProcesses.jl"/><meta property="og:title" content="API reference · PointProcesses.jl"/><meta property="twitter:title" content="API reference · PointProcesses.jl"/><meta name="description" content="Documentation for PointProcesses.jl."/><meta property="og:description" content="Documentation for PointProcesses.jl."/><meta property="twitter:description" content="Documentation for PointProcesses.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="PointProcesses.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="PointProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PointProcesses.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Histories"><span>Histories</span></a></li><li><a class="tocitem" href="#Point-processes"><span>Point processes</span></a></li><li><a class="tocitem" href="#Poisson-processes"><span>Poisson processes</span></a></li><li><a class="tocitem" href="#Inhomogeneous-Poisson-Process"><span>Inhomogeneous Poisson Process</span></a></li><li><a class="tocitem" href="#Hawkes-Process"><span>Hawkes Process</span></a></li><li><a class="tocitem" href="#Goodness-of-fit-tests"><span>Goodness-of-fit tests</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoseKling/PointProcesses.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoseKling/PointProcesses.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PointProcesses"><a class="docstring-binding" href="#PointProcesses"><code>PointProcesses</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">PointProcesses</code></pre><p>A package for temporal point process modeling, simulation and inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/PointProcesses.jl#L1-L5">source</a></section></details></article><h2 id="Histories"><a class="docs-heading-anchor" href="#Histories">Histories</a><a id="Histories-1"></a><a class="docs-heading-anchor-permalink" href="#Histories" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.History"><a class="docstring-binding" href="#PointProcesses.History"><code>PointProcesses.History</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">History{T&lt;:Real, M}</code></pre><p>Linear event histories with temporal locations of type <code>T</code> and marks of type <code>M</code>.</p><p><strong>Fields</strong></p><ul><li><code>times::Vector{T}</code>: sorted vector of event times</li><li><code>tmin::T</code>: start time</li><li><code>tmax::T</code>: end time</li><li><code>marks::Vector{M}</code>: associated vector of event marks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L1-L12">source</a></section></details></article><h3 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.event_marks"><a class="docstring-binding" href="#PointProcesses.event_marks"><code>PointProcesses.event_marks</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">event_marks(h)</code></pre><p>Return the vector of event marks for <code>h</code>, sorted according to their event times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L84-L88">source</a></section><section><div><pre><code class="language-julia hljs">event_marks(h, tmin, tmax)</code></pre><p>Return the sorted vector of marks of events between <code>tmin</code> and <code>tmax</code> in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.event_times"><a class="docstring-binding" href="#PointProcesses.event_times"><code>PointProcesses.event_times</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">event_times(h)</code></pre><p>Return the sorted vector of event times for <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L68-L72">source</a></section><section><div><pre><code class="language-julia hljs">event_times(h, tmin, tmax)</code></pre><p>Return the sorted vector of event times between <code>tmin</code> and <code>tmax</code> in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L75-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.min_time"><a class="docstring-binding" href="#PointProcesses.min_time"><code>PointProcesses.min_time</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">min_time(h)</code></pre><p>Return the starting time of <code>h</code> (not the same as the first event time).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L100-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.max_time"><a class="docstring-binding" href="#PointProcesses.max_time"><code>PointProcesses.max_time</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">max_time(h)</code></pre><p>Return the end time of <code>h</code> (not the same as the last event time).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L107-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.nb_events"><a class="docstring-binding" href="#PointProcesses.nb_events"><code>PointProcesses.nb_events</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nb_events(h)</code></pre><p>Count events in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L114-L118">source</a></section><section><div><pre><code class="language-julia hljs">nb_events(h, tmin, tmax)</code></pre><p>Count events in <code>h</code> during the interval <code>[tmin, tmax)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L128-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.has_events"><a class="docstring-binding" href="#PointProcesses.has_events"><code>PointProcesses.has_events</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_events(h)</code></pre><p>Check the presence of events in <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L139-L143">source</a></section><section><div><pre><code class="language-julia hljs">has_events(h, tmin, tmax)</code></pre><p>Check the presence of events in <code>h</code> during the interval <code>[tmin, tmax)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length"><a class="docstring-binding" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">length(h)</code></pre><p>Alias for <code>nb_events(h)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L121-L125">source</a></section><section><div><pre><code class="language-julia hljs">length(pp::MultivariatePoissonProcess)</code></pre><p>Return the number of marks (dimensions) in a multivariate Poisson process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/poisson_process.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.duration"><a class="docstring-binding" href="#PointProcesses.duration"><code>PointProcesses.duration</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">duration(h)</code></pre><p>Compute the difference <code>h.tmax - h.tmin</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.min_mark"><a class="docstring-binding" href="#PointProcesses.min_mark"><code>PointProcesses.min_mark</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">min_mark(h; [init])</code></pre><p>Return the smallest event mark if it is smaller than <code>init</code>, and <code>init</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L252-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.max_mark"><a class="docstring-binding" href="#PointProcesses.max_mark"><code>PointProcesses.max_mark</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">max_mark(h; [init])</code></pre><p>Return the largest event mark if it is larger than <code>init</code>, and <code>init</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L245-L249">source</a></section></details></article><h3 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Base.push!"><a class="docstring-binding" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">push!(h, t, m)</code></pre><p>Add event <code>(t, m)</code> inside the interval <code>[h.tmin, h.tmax)</code> at the end of history <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.append!"><a class="docstring-binding" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">append!(h, ts, ms)</code></pre><p>Append events <code>(ts, ms)</code> inside the interval <code>[h.tmin, h.tmax)</code> at the end of history <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L175-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.cat"><a class="docstring-binding" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cat(h1, h2)</code></pre><p>If h1 and h2 are consecutive event histories, i.e., the end of h1 coincides with the beginning of h2, then create a new event history by concatenating h1 and h2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L193-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.time_change"><a class="docstring-binding" href="#PointProcesses.time_change"><code>PointProcesses.time_change</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_change(h, Λ)</code></pre><p>Apply the time rescaling <code>t -&gt; Λ(t)</code> to history <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L212-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.split_into_chunks"><a class="docstring-binding" href="#PointProcesses.split_into_chunks"><code>PointProcesses.split_into_chunks</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">split_into_chunks(h, chunk_duration)</code></pre><p>Split <code>h</code> into a vector of consecutive histories with individual duration <code>chunk_duration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/history.jl#L225-L229">source</a></section></details></article><h2 id="Point-processes"><a class="docs-heading-anchor" href="#Point-processes">Point processes</a><a id="Point-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Point-processes" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.AbstractPointProcess"><a class="docstring-binding" href="#PointProcesses.AbstractPointProcess"><code>PointProcesses.AbstractPointProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPointProcess</code></pre><p>Common interface for all temporal point processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.BoundedPointProcess"><a class="docstring-binding" href="#PointProcesses.BoundedPointProcess"><code>PointProcesses.BoundedPointProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BoundedPointProcess{P,T} &lt;: AbstractPointProcess{}</code></pre><p>Temporal point process <code>P</code> with pre-defined start and end times.</p><p>Implements some fallbacks for the <code>AbstractPointProcess</code> interface which accept fewer arguments.</p><p><strong>Fields</strong></p><ul><li><code>pp::P</code>: underlying point process</li><li><code>tmin::T</code>: start time</li><li><code>tmax::T</code>: end time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/bounded_point_process.jl#L1-L13">source</a></section></details></article><h3 id="Intensity"><a class="docs-heading-anchor" href="#Intensity">Intensity</a><a id="Intensity-1"></a><a class="docs-heading-anchor-permalink" href="#Intensity" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.intensity"><a class="docstring-binding" href="#PointProcesses.intensity"><code>PointProcesses.intensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensity(pp, m, t, h)</code></pre><p>Compute the conditional intensity for a temporal point process <code>pp</code> applied to history <code>h</code> and event <code>(t, m)</code>.</p><p>The conditional intensity function <code>λ(t,m|h)</code> quantifies the instantaneous risk of an event with mark <code>m</code> occurring at time <code>t</code> after history <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L31-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.ground_intensity"><a class="docstring-binding" href="#PointProcesses.ground_intensity"><code>PointProcesses.ground_intensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ground_intensity(pp, h, t)</code></pre><p>Compute the ground intensity for a temporal point process <code>pp</code> applied to history <code>h</code> at time <code>t</code>.</p><p>The ground intensity quantifies the instantaneous risk of an event with any mark occurring at time <code>t</code> after history <code>h</code>:</p><pre><code class="language-julia hljs">λg(t|h) = Σₘ λ(t,m|h)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L12-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.log_intensity"><a class="docstring-binding" href="#PointProcesses.log_intensity"><code>PointProcesses.log_intensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">log_intensity(pp, m, t, h)</code></pre><p>Compute the logarithm of the conditional intensity for a temporal point process <code>pp</code> applied to history <code>h</code> and event <code>(t, m)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.intensity_vector"><a class="docstring-binding" href="#PointProcesses.intensity_vector"><code>PointProcesses.intensity_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensity_vector(pp&lt;:MultivariatePoissonProcess)</code></pre><p>Compute the vector of the marginal intensities <code>λ</code> for a multivariate Poisson process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/poisson_process.jl#L102-L106">source</a></section></details></article><h3 id="Marks"><a class="docs-heading-anchor" href="#Marks">Marks</a><a id="Marks-1"></a><a class="docs-heading-anchor-permalink" href="#Marks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.mark_distribution"><a class="docstring-binding" href="#PointProcesses.mark_distribution"><code>PointProcesses.mark_distribution</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mark_distribution(pp, t, h)</code></pre><p>Compute the distribution of marks for a temporal point process <code>pp</code> knowing that an event takes place at time <code>t</code> after history <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L24-L28">source</a></section></details></article><h3 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.simulate_ogata"><a class="docstring-binding" href="#PointProcesses.simulate_ogata"><code>PointProcesses.simulate_ogata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simulate_ogata(rng, pp, tmin, tmax)</code></pre><p>Simulate a temporal point process <code>pp</code> on interval <code>[tmin, tmax)</code> using Ogata&#39;s algorithm.</p><p><strong>Technical Remark</strong></p><p>To infer the type of the marks, the implementation assumes that there is method of <code>mark_distribution</code> without the argument <code>h</code> such that it corresponds to the distribution of marks in case the history is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/simulation.jl#L14-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.simulate"><a class="docstring-binding" href="#PointProcesses.simulate"><code>PointProcesses.simulate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simulate([rng,] pp, tmin, tmax)</code></pre><p>Alias for <code>simulate_ogata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/simulation.jl#L48-L52">source</a></section><section><div><pre><code class="language-julia hljs">simulate([rng,] bpp::BoundedPointProcess)</code></pre><p>Simulate a point process on a predefined time interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/bounded_point_process.jl#L23-L27">source</a></section></details></article><h3 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DensityInterface.logdensityof"><a class="docstring-binding" href="#DensityInterface.logdensityof"><code>DensityInterface.logdensityof</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logdensityof(pp, h)</code></pre><p>Compute the log probability density function for a temporal point process <code>pp</code> applied to history <code>h</code>:</p><pre><code class="language-julia hljs">ℓ(h) = Σₖ log λ(tₖ|hₖ) - Λ(h)</code></pre><p>The default method uses a loop over events combined with <code>integrated_ground_intensity</code>, but it should be reimplemented for specific processes if faster computation is possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L72-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.integrated_ground_intensity"><a class="docstring-binding" href="#PointProcesses.integrated_ground_intensity"><code>PointProcesses.integrated_ground_intensity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">integrated_ground_intensity(pp, h, a, b)</code></pre><p>Compute the integrated ground intensity (or compensator) <code>Λ(t|h)</code> for a temporal point process <code>pp</code> applied to history <code>h</code> on interval <code>[a, b)</code>:</p><pre><code class="language-julia hljs">Λ(h) = ∫ λg(t|h) dt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L62-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.ground_intensity_bound"><a class="docstring-binding" href="#PointProcesses.ground_intensity_bound"><code>PointProcesses.ground_intensity_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ground_intensity_bound(pp, t, h)</code></pre><p>Compute a local upper bound on the ground intensity for a temporal point process <code>pp</code> applied to history <code>h</code> at time <code>t</code>.</p><p>Return a tuple of the form <code>(B, L)</code> satisfying <code>λg(t|h) ≤ B</code> for all <code>u ∈ [t, t+L)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L51-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.fit"><a class="docstring-binding" href="#StatsAPI.fit"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit(::Type{PP}, h)
fit(::Type{PP}, histories)</code></pre><p>Fit a point process of type <code>PP</code> to one or several histories.</p><p>Not implemented by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L89-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.fit_map"><a class="docstring-binding" href="#PointProcesses.fit_map"><code>PointProcesses.fit_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit_map(::Type{PP}, h, prior)
fit_map(::Type{PP}, histories, prior)</code></pre><p>Fit a point process of type <code>PP</code> to one or several histories using maximum a posteriori with a <code>prior</code>.</p><p>Not implemented by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/abstract_point_process.jl#L99-L106">source</a></section></details></article><h2 id="Poisson-processes"><a class="docs-heading-anchor" href="#Poisson-processes">Poisson processes</a><a id="Poisson-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Poisson-processes" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.PoissonProcess"><a class="docstring-binding" href="#PointProcesses.PoissonProcess"><code>PointProcesses.PoissonProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PoissonProcess{R,D}</code></pre><p>Homogeneous temporal Poisson process with arbitrary mark distribution.</p><p><strong>Fields</strong></p><ul><li><code>λ::R</code>: ground intensity.</li><li><code>mark_dist::D</code>: mark distribution.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PoissonProcess(λ, mark_dist)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/poisson_process.jl#L1-L14">source</a></section></details></article><h3 id="Univariate"><a class="docs-heading-anchor" href="#Univariate">Univariate</a><a id="Univariate-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.UnivariatePoissonProcess"><a class="docstring-binding" href="#PointProcesses.UnivariatePoissonProcess"><code>PointProcesses.UnivariatePoissonProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnivariatePoissonProcess{R}</code></pre><p>Homogeneous univariate temporal Poisson process with scalar intensity <code>λ::R</code>.</p><p><code>UnivariatePoissonProcess{R}</code> is simply a type alias for <code>PoissonProcess{R,Dirac{Nothing}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/poisson_process.jl#L36-L42">source</a></section></details></article><h3 id="Multivariate"><a class="docs-heading-anchor" href="#Multivariate">Multivariate</a><a id="Multivariate-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.MultivariatePoissonProcess"><a class="docstring-binding" href="#PointProcesses.MultivariatePoissonProcess"><code>PointProcesses.MultivariatePoissonProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultivariatePoissonProcess{R}</code></pre><p>Homogeneous multivariate temporal Poisson process with marginal intensities of type <code>R</code>.</p><p><code>MultivariatePoissonProcess{R}</code> is simply a type alias for <code>PoissonProcess{R,Categorical{Float64,Vector{Float64}}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/poisson_process.jl#L49-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.MultivariatePoissonProcessPrior"><a class="docstring-binding" href="#PointProcesses.MultivariatePoissonProcessPrior"><code>PointProcesses.MultivariatePoissonProcessPrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultivariatePoissonProcessPrior{R1,R2}</code></pre><p>Gamma prior on all the event rates of a <code>MultivariatePoissonProcess</code>.</p><p><strong>Fields</strong></p><ul><li><code>α::Vector{R1}</code></li><li><code>β::R2</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/prior.jl#L1-L10">source</a></section></details></article><h2 id="Inhomogeneous-Poisson-Process"><a class="docs-heading-anchor" href="#Inhomogeneous-Poisson-Process">Inhomogeneous Poisson Process</a><a id="Inhomogeneous-Poisson-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Inhomogeneous-Poisson-Process" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.InhomogeneousPoissonProcess"><a class="docstring-binding" href="#PointProcesses.InhomogeneousPoissonProcess"><code>PointProcesses.InhomogeneousPoissonProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InhomogeneousPoissonProcess{F,M,C}</code></pre><p>Inhomogeneous temporal Poisson process with time-varying intensity.</p><p><strong>Fields</strong></p><ul><li><code>intensity_function::F</code>: callable intensity function λ(t).</li><li><code>mark_dist::M</code>: mark distribution.</li><li><code>integration_config::C</code>: configuration for numerical integration.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">InhomogeneousPoissonProcess(intensity_function, mark_dist; integration_config=IntegrationConfig())</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Linear intensity
pp = InhomogeneousPoissonProcess(PolynomialIntensity([1.0, 0.5]), Normal())

# Sinusoidal intensity
pp = InhomogeneousPoissonProcess(SinusoidalIntensity(5.0, 2.0, 2π), Categorical([0.3, 0.7]))

# Custom intensity function
pp = InhomogeneousPoissonProcess(t -&gt; 1.0 + 0.5*sin(t), Uniform())

# Custom integration settings
pp = InhomogeneousPoissonProcess(
    my_intensity,
    Normal(),
    integration_config=IntegrationConfig(abstol=1e-10)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/inhomogeneous_poisson_process.jl#L1-L35">source</a></section></details></article><h3 id="Intensity-Functions"><a class="docs-heading-anchor" href="#Intensity-Functions">Intensity Functions</a><a id="Intensity-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Intensity-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.ParametricIntensity"><a class="docstring-binding" href="#PointProcesses.ParametricIntensity"><code>PointProcesses.ParametricIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParametricIntensity</code></pre><p>Abstract trait for intensity functions that can be parameterized for MLE fitting.</p><p>Any intensity type that implements this interface must provide:</p><ul><li><code>from_params(::Type{F}, params)</code>: Construct intensity function from parameters</li></ul><p>The parameter space should be unconstrained (e.g., use log-transforms for positive parameters).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/parametric_intensity.jl#L8-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.PolynomialIntensity"><a class="docstring-binding" href="#PointProcesses.PolynomialIntensity"><code>PointProcesses.PolynomialIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolynomialIntensity{R&lt;:Real,L} &lt;: ParametricIntensity</code></pre><p>Polynomial intensity function with optional link function.</p><p><strong>Fields</strong></p><ul><li><code>coefficients::Vector{R}</code>: polynomial coefficients [a₀, a₁, ..., aₙ].</li><li><code>link::L</code>: link function applied to the polynomial (<code>:identity</code> or <code>:log</code>).</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PolynomialIntensity(coefficients; link=:identity)</code></pre><p>When <code>link=:identity</code>: λ(t) = a₀ + a₁<em>t + a₂</em>t² + ... + aₙ<em>tⁿ When <code>link=:log</code>: λ(t) = exp(a₀ + a₁</em>t + a₂<em>t² + ... + aₙ</em>tⁿ)</p><p>The log link ensures positivity of the intensity function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Linear identity: λ(t) = 2 + 3*t (may be negative!)
PolynomialIntensity([2.0, 3.0])

# Linear log: λ(t) = exp(2 + 3*t) (always positive)
PolynomialIntensity([2.0, 3.0]; link=:log)

# Quadratic: λ(t) = 1 + 2*t + 0.5*t²
PolynomialIntensity([1.0, 2.0, 0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L7-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.ExponentialIntensity"><a class="docstring-binding" href="#PointProcesses.ExponentialIntensity"><code>PointProcesses.ExponentialIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExponentialIntensity{R&lt;:Real} &lt;: ParametricIntensity</code></pre><p>Exponential intensity function: λ(t) = a<em>exp(b</em>t).</p><p><strong>Fields</strong></p><ul><li><code>a::R</code>: scaling factor (must be positive).</li><li><code>b::R</code>: exponential rate.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ExponentialIntensity(a, b)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Increasing intensity
ExponentialIntensity(2.0, 0.1)

# Decreasing intensity
ExponentialIntensity(5.0, -0.05)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L71-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.SinusoidalIntensity"><a class="docstring-binding" href="#PointProcesses.SinusoidalIntensity"><code>PointProcesses.SinusoidalIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SinusoidalIntensity{R&lt;:Real} &lt;: ParametricIntensity</code></pre><p>Sinusoidal intensity function: λ(t) = a + b<em>sin(ω</em>t + φ).</p><p>To ensure positivity, we require a &gt;= |b| so that λ(t) &gt;= 0 for all t.</p><p><strong>Fields</strong></p><ul><li><code>a::R</code>: baseline intensity (must satisfy a &gt;= |b|).</li><li><code>b::R</code>: amplitude.</li><li><code>ω::R</code>: angular frequency.</li><li><code>φ::R</code>: phase shift.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SinusoidalIntensity(a, b, ω, φ=0.0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Valid: a=5, b=2, so a &gt;= |b|
SinusoidalIntensity(5.0, 2.0, 2π)

# Valid: a=5, b=-3, so a &gt;= |-3| = 3
SinusoidalIntensity(5.0, -3.0, 2π)

# Invalid: a=2, b=3, so a &lt; |b| (will error)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L119-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.PiecewiseConstantIntensity"><a class="docstring-binding" href="#PointProcesses.PiecewiseConstantIntensity"><code>PointProcesses.PiecewiseConstantIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PiecewiseConstantIntensity{R&lt;:Real}</code></pre><p>Piecewise constant intensity function.</p><p><strong>Fields</strong></p><ul><li><code>breakpoints::Vector{R}</code>: sorted vector of breakpoints (including tmin and tmax).</li><li><code>rates::Vector{R}</code>: intensity values for each interval.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PiecewiseConstantIntensity(breakpoints, rates)</code></pre><p>The intensity is <code>rates[i]</code> for <code>t ∈ [breakpoints[i], breakpoints[i+1])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L183-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.LinearCovariateIntensity"><a class="docstring-binding" href="#PointProcesses.LinearCovariateIntensity"><code>PointProcesses.LinearCovariateIntensity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearCovariateIntensity{R&lt;:Real,F}</code></pre><p>Linear combination of covariate functions: λ(t) = β₀ + β₁<em>x₁(t) + β₂</em>x₂(t) + ... + βₙ*xₙ(t).</p><p><strong>Fields</strong></p><ul><li><code>intercept::R</code>: intercept term β₀.</li><li><code>coefficients::Vector{R}</code>: coefficients [β₁, β₂, ..., βₙ].</li><li><code>covariates::Vector{F}</code>: covariate functions [x₁, x₂, ..., xₙ], each callable with signature <code>xᵢ(t)</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LinearCovariateIntensity(intercept, coefficients, covariates)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># With time and sin(time) as covariates
LinearCovariateIntensity(1.0, [0.5, 2.0], [t -&gt; t, t -&gt; sin(t)])

# With custom covariate functions
temp_func = t -&gt; 20 + 5*sin(2π*t/365)  # seasonal temperature
wind_func = t -&gt; 10 + 2*rand()          # wind speed
LinearCovariateIntensity(0.1, [0.05, 0.02], [temp_func, wind_func])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L231-L257">source</a></section></details></article><h3 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.from_params"><a class="docstring-binding" href="#PointProcesses.from_params"><code>PointProcesses.from_params</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">from_params</code></pre><p>Method used in optimization, where parameters are returned as vectors. Can be used to perform a transformation in the parameter space. Example:</p><pre><code class="language-julia hljs">struct Constant{R} &lt;: ParametricIntensity
    a::R
end where {R&lt;:Real}
(f::Constant, t::Real) = f.a

# Optimization procedure uses this method to calculate the objective.
# This is not constrained to positive parameter values anymore
function from_params(::Constant, params)
    return Constant(exp(params[1]))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/parametric_intensity.jl#L20-L37">source</a></section><section><div><pre><code class="language-julia hljs">from_params(::Type{PolynomialIntensity{R}}, params; link=:identity)</code></pre><p>Construct PolynomialIntensity from parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L291-L295">source</a></section><section><div><pre><code class="language-julia hljs">from_params(::Type{ExponentialIntensity{R}}, params)</code></pre><p>Construct ExponentialIntensity from unconstrained parameters: params = [log(a), b].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L304-L308">source</a></section><section><div><pre><code class="language-julia hljs">from_params(::Type{SinusoidalIntensity{R}}, params; ω=2π)</code></pre><p>Construct SinusoidalIntensity from unconstrained parameters.</p><p>Parameters: [p₁, p₂, p₃] where a = exp(p₁), b = tanh(p₂)*a, φ = p₃. The ω (angular frequency) must be specified separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/intensity_functions.jl#L314-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.IntegrationConfig"><a class="docstring-binding" href="#PointProcesses.IntegrationConfig"><code>PointProcesses.IntegrationConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntegrationConfig</code></pre><p>Configuration for numerical integration of intensity functions.</p><p><strong>Fields</strong></p><ul><li><code>solver</code>: Integration solver from Integrals.jl (e.g., QuadGKJL(), HCubatureJL())</li><li><code>abstol::Float64</code>: Absolute tolerance for integration</li><li><code>reltol::Float64</code>: Relative tolerance for integration</li><li><code>maxiters::Int</code>: Maximum number of iterations</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">IntegrationConfig(; solver=QuadGKJL(), abstol=1e-8, reltol=1e-8, maxiters=1000)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default configuration
config = IntegrationConfig()

# Higher precision
config = IntegrationConfig(abstol=1e-12, reltol=1e-12)

# Different solver
using Integrals
config = IntegrationConfig(solver=HCubatureJL())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/poisson/inhomogeneous/integration_config.jl#L1-L30">source</a></section></details></article><h2 id="Hawkes-Process"><a class="docs-heading-anchor" href="#Hawkes-Process">Hawkes Process</a><a id="Hawkes-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Hawkes-Process" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.HawkesProcess"><a class="docstring-binding" href="#PointProcesses.HawkesProcess"><code>PointProcesses.HawkesProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HawkesProcess{T&lt;:Real}</code></pre><p>Univariate Hawkes process with exponential decay kernel.</p><p>A Hawkes process is a self-exciting point process where each event increases the probability of future events. The conditional intensity function is given by:</p><pre><code class="language-julia hljs">λ(t) = μ + α ∑_{tᵢ &lt; t} exp(-ω(t - tᵢ))</code></pre><p>where the sum is over all previous event times tᵢ.</p><p><strong>Fields</strong></p><ul><li><code>μ::T</code>: baseline intensity (immigration rate)</li><li><code>α::T</code>: jump size (immediate increase in intensity after an event)  </li><li><code>ω::T</code>: decay rate (how quickly the excitement fades)</li></ul><p>Conditions:</p><ul><li>μ, α, ω &gt;= 0</li><li>ψ = α/ω &lt; 1 → Stability condition. ψ is the expected number of events each event generates</li></ul><p>Following the notation from <a href="https://arxiv.org/pdf/1801.08273">E. Lewis, G. Mohler (2011)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/hawkes/hawkes_process.jl#L1-L24">source</a></section></details></article><h2 id="Goodness-of-fit-tests"><a class="docs-heading-anchor" href="#Goodness-of-fit-tests">Goodness-of-fit tests</a><a id="Goodness-of-fit-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Goodness-of-fit-tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PointProcesses.Statistic"><a class="docstring-binding" href="#PointProcesses.Statistic"><code>PointProcesses.Statistic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Statistic</code></pre><p>Interface for all test statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/statistic.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.statistic"><a class="docstring-binding" href="#PointProcesses.statistic"><code>PointProcesses.statistic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">statistic(::Statistic, pp::AbstractPointProcess, h::History)</code></pre><p>Compute the value of the test statistic with respect to <code>pp</code> and <code>h</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Statistic</code>: The type of test statistic to be computed</li><li><code>pp::AbstractPointProcess</code>: null-hypothesis model for the event history <code>h</code></li><li><code>h::History</code>: the observed event history</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: the resulting test statistic</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">#=
Calculate the Kolmogorov-Smirnov distance between the distribution of the
time-changed event times of `h` and a standard exponential.
=#
ks_stat = statistic(KSDistance{Exponential}, hawkes_process, history)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/statistic.jl#L8-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.PointProcessTest"><a class="docstring-binding" href="#PointProcesses.PointProcessTest"><code>PointProcesses.PointProcessTest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PointProcessTest</code></pre><p>Interface for all goodness-of-fit tests</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/point_process_tests.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.pvalue"><a class="docstring-binding" href="#StatsAPI.pvalue"><code>StatsAPI.pvalue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvalue(test::PointProcessTest)</code></pre><p>Calculate the p-value of a goodness-of-fit test on a process.</p><p><strong>Arguments</strong></p><ul><li><code>::PointProcessTest</code>: the test result object</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: p-value in [0, 1], where small values provide evidence against the null hypothesis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/point_process_tests.jl#L8-L18">source</a></section></details></article><h3 id="Statistic"><a class="docs-heading-anchor" href="#Statistic">Statistic</a><a id="Statistic-1"></a><a class="docs-heading-anchor-permalink" href="#Statistic" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.KSDistance"><a class="docstring-binding" href="#PointProcesses.KSDistance"><code>PointProcesses.KSDistance</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KSDistance{T&lt;:UnivariateDistribution}</code></pre><p>A Kolmogorov-Smirnov distance statistic for testing goodness-of-fit of point processes against a specified distribution <code>D</code> after appropriate time rescaling. This test statistic is suitable only for non-marked processes, as it ignores the marks.</p><p><strong>Type parameter</strong></p><ul><li><code>D&lt;:UnivariateDistribution</code>: the target distribution to test against (e.g., <code>Exponential</code>, <code>Uniform</code>)</li></ul><p><strong>Available test statistics</strong></p><ul><li><p>KSDistance{Exponential}   Kolmogorov-Smirnov distance between the time-changed interevent times and a standard exponential</p></li><li><p>KSDistance{Uniform}   Kolmogorov-Smirnov distance between the time-changed event times and a uniform distribution</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">BootstrapTest(KSDistance{Exponential}, HawkesProcess, history)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/Statistics/KSDistance.jl#L1-L22">source</a></section></details></article><h3 id="BootstrapTest"><a class="docs-heading-anchor" href="#BootstrapTest">BootstrapTest</a><a id="BootstrapTest-1"></a><a class="docs-heading-anchor-permalink" href="#BootstrapTest" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.BootstrapTest"><a class="docstring-binding" href="#PointProcesses.BootstrapTest"><code>PointProcesses.BootstrapTest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BootstrapTest &lt;: PointProcessTest</code></pre><p>An object containing the results of a bootstrap-based goodness-of-fit test. The p-value of the test is calculated as     p = (count(sim<em>stats ≥ stat) + 1) / (n</em>sims + 1).</p><p><strong>Fields</strong></p><ul><li><code>n_sims::Int</code>: number of bootstrap simulations performed</li><li><code>stat::Float64</code>: observed test statistic value</li><li><code>sim_stats::Vector{Float64}</code>: test statistics from bootstrap simulations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/PPTests/bootstrap_test.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.BootstrapTest-Tuple{Type{&lt;:Statistic}, Type{&lt;:AbstractPointProcess}, History}"><a class="docstring-binding" href="#PointProcesses.BootstrapTest-Tuple{Type{&lt;:Statistic}, Type{&lt;:AbstractPointProcess}, History}"><code>PointProcesses.BootstrapTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BootstrapTest(S::Type{&lt;:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())</code></pre><p>Perform a goodness-of-fit test using simulation with bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.</p><p>If λ₀(t) is the true intensity function of the process that generated the observed history, and λ(t; θ) is a a parametrization of the intensity, then the null hypothesis is</p><pre><code class="language-julia hljs">H₀: There exists parameters θₒ such that λ₀(t) = λ(t; θ₀)</code></pre><p>This procedure is specifically aimed for testing hypotheses where parameters need to be estimated. Details are provided in <a href="https://doi.org/10.1111/sjos.70029">Kling and Vetter (2025)</a>.</p><p><strong>Arguments</strong></p><ul><li><code>S::Type{&lt;:Statistic}</code>: the type of test statistic to use</li><li><code>pp::Type{&lt;:AbstractPointProcess}</code>: the null hypothesis model family</li><li><code>h::History</code>: the observed event history</li><li><code>n_sims::Int=1000</code>: number of bootstrap simulations to perform</li><li><code>rng::AbstractRNG=default_rng()</code>: Random number generator</li></ul><p><strong>Returns</strong></p><ul><li><code>BootstrapTest</code>: test result object containing the observed statistic, bootstrap statistics, and test metadata</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Bootstrap test for Hawkes process model adequacy
test = BootstrapTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)
p = pvalue(test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/PPTests/bootstrap_test.jl#L29-L61">source</a></section></details></article><h3 id="NoBootstrapTest"><a class="docs-heading-anchor" href="#NoBootstrapTest">NoBootstrapTest</a><a id="NoBootstrapTest-1"></a><a class="docs-heading-anchor-permalink" href="#NoBootstrapTest" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="PointProcesses.MonteCarloTest"><a class="docstring-binding" href="#PointProcesses.MonteCarloTest"><code>PointProcesses.MonteCarloTest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MonteCarloTest &lt;: PointProcessTest</code></pre><p>An object containing the results of a non-bootstrap based goodness-of-fit test. The p-value of the test is calculated as     p = (count(sim<em>stats ≥ stat) + 1) / (n</em>sims + 1).</p><p><strong>Fields</strong></p><ul><li><code>n_sims::Int</code>: number of simulations performed</li><li><code>stat::Float64</code>: observed test statistic value</li><li><code>sim_stats::Vector{Float64}</code>: test statistics from simulated data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/PPTests/monte_carlo_test.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PointProcesses.MonteCarloTest-Tuple{Type{&lt;:Statistic}, AbstractPointProcess, History}"><a class="docstring-binding" href="#PointProcesses.MonteCarloTest-Tuple{Type{&lt;:Statistic}, AbstractPointProcess, History}"><code>PointProcesses.MonteCarloTest</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MonteCarloTest(S::Type{&lt;:Statistic}, pp::AbstractPointProcess, h::History; n_sims::Int=1000, rng::AbstractRNG=default_rng())</code></pre><p>Perform a goodness-of-fit test using simulation without bootstrap resampling, comparing the test statistic computed on the observed data against the distribution of the same statistic computed on data simulated from the fitted model.</p><p>If λ₀(t) is the true intensity function of the process that generated the observed history, and λ(t; θ) is a a parametrization of the intensity, then there are two forms for the null hypothesis:</p><pre><code class="language-julia hljs">1. H₀: λ₀(t) = λ(t; θ₀)
2. H₀: There exists parameters θₒ such that λ₀(t) = λ(t; θ₀)</code></pre><p>If <code>pp</code> is an instance of an <code>AbstractPointProcess</code>, the null hypothesis 1 is considered, if a <code>pp</code> is a <code>Type{&lt;:AbstractPointProcess}</code>, the method uses null hypothesis 2.</p><p>Notice that this test is better suited when the parameter θ₀ is known (form 1), since this procedure does not account for parameter estimation error. For more details on this, see <a href="http://www.jstor.org/stable/25053332">Jogesh Babu and Rao (2004)</a>, <a href="https://doi.org/10.1186/2190-8567-4-3">Reynaud-Bouret et. al. (2014)</a>,  <a href="https://doi.org/10.1111/sjos.70029">Kling and Vetter (2025)</a>.</p><p><strong>Arguments</strong></p><ul><li><code>S::Type{&lt;:Statistic}</code>: the type of test statistic to use</li><li><code>pp::Union{AbstractPointProcess, Type{&lt;:AbstractPointProcess}}</code>: the null hypothesis model family</li><li><code>h::History</code>: the observed event history</li><li><code>n_sims::Int=1000</code>: number of simulations to perform for the test</li><li><code>rng::AbstractRNG=default_rng()</code>: Random number generator</li></ul><p><strong>Returns</strong></p><ul><li><code>MonteCarloTest</code>: test result object containing the observed statistic, simulated statistics, and test metadata</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Test null hypothesis of form 1. Known θ₀
test = MonteCarloTest(KSDistance(Exponential), HawkesProcess(1, 1, 2), history; n_sims=1000)
p = pvalue(test)
# Test null hypothesis of form 2. Unknown θ₀
test = MonteCarloTest(KSDistance(Exponential), HawkesProcess, history; n_sims=1000)
p = pvalue(test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoseKling/PointProcesses.jl/blob/66f009e86b0f29083216b20b426b1f01840213cf/src/HypothesisTests/PPTests/monte_carlo_test.jl#L23-L65">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PointProcesses.AbstractPointProcess"><code>PointProcesses.AbstractPointProcess</code></a></li><li><a href="#PointProcesses.BootstrapTest-Tuple{Type{&lt;:Statistic}, Type{&lt;:AbstractPointProcess}, History}"><code>PointProcesses.BootstrapTest</code></a></li><li><a href="#PointProcesses.BootstrapTest"><code>PointProcesses.BootstrapTest</code></a></li><li><a href="#PointProcesses.BoundedPointProcess"><code>PointProcesses.BoundedPointProcess</code></a></li><li><a href="#PointProcesses.ExponentialIntensity"><code>PointProcesses.ExponentialIntensity</code></a></li><li><a href="#PointProcesses.HawkesProcess"><code>PointProcesses.HawkesProcess</code></a></li><li><a href="#PointProcesses.History"><code>PointProcesses.History</code></a></li><li><a href="#PointProcesses.InhomogeneousPoissonProcess"><code>PointProcesses.InhomogeneousPoissonProcess</code></a></li><li><a href="#PointProcesses.IntegrationConfig"><code>PointProcesses.IntegrationConfig</code></a></li><li><a href="#PointProcesses.KSDistance"><code>PointProcesses.KSDistance</code></a></li><li><a href="#PointProcesses.LinearCovariateIntensity"><code>PointProcesses.LinearCovariateIntensity</code></a></li><li><a href="#PointProcesses.MonteCarloTest"><code>PointProcesses.MonteCarloTest</code></a></li><li><a href="#PointProcesses.MonteCarloTest-Tuple{Type{&lt;:Statistic}, AbstractPointProcess, History}"><code>PointProcesses.MonteCarloTest</code></a></li><li><a href="#PointProcesses.MultivariatePoissonProcess"><code>PointProcesses.MultivariatePoissonProcess</code></a></li><li><a href="#PointProcesses.MultivariatePoissonProcessPrior"><code>PointProcesses.MultivariatePoissonProcessPrior</code></a></li><li><a href="#PointProcesses.ParametricIntensity"><code>PointProcesses.ParametricIntensity</code></a></li><li><a href="#PointProcesses.PiecewiseConstantIntensity"><code>PointProcesses.PiecewiseConstantIntensity</code></a></li><li><a href="#PointProcesses.PointProcessTest"><code>PointProcesses.PointProcessTest</code></a></li><li><a href="#PointProcesses.PoissonProcess"><code>PointProcesses.PoissonProcess</code></a></li><li><a href="#PointProcesses.PolynomialIntensity"><code>PointProcesses.PolynomialIntensity</code></a></li><li><a href="#PointProcesses.SinusoidalIntensity"><code>PointProcesses.SinusoidalIntensity</code></a></li><li><a href="#PointProcesses.Statistic"><code>PointProcesses.Statistic</code></a></li><li><a href="#PointProcesses.UnivariatePoissonProcess"><code>PointProcesses.UnivariatePoissonProcess</code></a></li><li><a href="#PointProcesses.duration"><code>PointProcesses.duration</code></a></li><li><a href="#PointProcesses.event_marks"><code>PointProcesses.event_marks</code></a></li><li><a href="#PointProcesses.event_times"><code>PointProcesses.event_times</code></a></li><li><a href="#PointProcesses.fit_map"><code>PointProcesses.fit_map</code></a></li><li><a href="#PointProcesses.from_params"><code>PointProcesses.from_params</code></a></li><li><a href="#PointProcesses.ground_intensity"><code>PointProcesses.ground_intensity</code></a></li><li><a href="#PointProcesses.ground_intensity_bound"><code>PointProcesses.ground_intensity_bound</code></a></li><li><a href="#PointProcesses.has_events"><code>PointProcesses.has_events</code></a></li><li><a href="#PointProcesses.integrated_ground_intensity"><code>PointProcesses.integrated_ground_intensity</code></a></li><li><a href="#PointProcesses.intensity"><code>PointProcesses.intensity</code></a></li><li><a href="#PointProcesses.intensity_vector"><code>PointProcesses.intensity_vector</code></a></li><li><a href="#PointProcesses.log_intensity"><code>PointProcesses.log_intensity</code></a></li><li><a href="#PointProcesses.mark_distribution"><code>PointProcesses.mark_distribution</code></a></li><li><a href="#PointProcesses.max_mark"><code>PointProcesses.max_mark</code></a></li><li><a href="#PointProcesses.max_time"><code>PointProcesses.max_time</code></a></li><li><a href="#PointProcesses.min_mark"><code>PointProcesses.min_mark</code></a></li><li><a href="#PointProcesses.min_time"><code>PointProcesses.min_time</code></a></li><li><a href="#PointProcesses.nb_events"><code>PointProcesses.nb_events</code></a></li><li><a href="#PointProcesses.simulate"><code>PointProcesses.simulate</code></a></li><li><a href="#PointProcesses.simulate_ogata"><code>PointProcesses.simulate_ogata</code></a></li><li><a href="#PointProcesses.split_into_chunks"><code>PointProcesses.split_into_chunks</code></a></li><li><a href="#PointProcesses.statistic"><code>PointProcesses.statistic</code></a></li><li><a href="#PointProcesses.time_change"><code>PointProcesses.time_change</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 19 December 2025 14:59">Friday 19 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
